<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="/jekyll-theme-yat/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-06-30T14:04:32+00:00</updated><id>/jekyll-theme-yat/feed.xml</id><title type="html">대현’s 개발일지</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Yun Daehyun</name></author><entry><title type="html">(스프링 기본) Domain, Repository, Service, Controller</title><link href="/jekyll-theme-yat/spring/2024/06/21/(%EC%8A%A4%ED%94%84%EB%A7%81-%EA%B8%B0%EB%B3%B8)-Domain,-Repository,-Service,-Controller.html" rel="alternate" type="text/html" title="(스프링 기본) Domain, Repository, Service, Controller" /><published>2024-06-21T00:00:00+00:00</published><updated>2024-06-21T00:00:00+00:00</updated><id>/jekyll-theme-yat/spring/2024/06/21/(%EC%8A%A4%ED%94%84%EB%A7%81-%EA%B8%B0%EB%B3%B8)-Domain,-Repository,-Service,-Controller</id><content type="html" xml:base="/jekyll-theme-yat/spring/2024/06/21/(%EC%8A%A4%ED%94%84%EB%A7%81-%EA%B8%B0%EB%B3%B8)-Domain,-Repository,-Service,-Controller.html"><![CDATA[<h2 id="웹-애플리케이션-계층-구조">웹 애플리케이션 계층 구조</h2>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/69f34114-e526-4f7a-b572-68437c9778a4" alt="image" /></p>

<h2 id="domain">Domain</h2>

<h3 id="도메인-모델">도메인 모델</h3>
<ul>
  <li>도메인 모델이란 특정 문제와 관련된 모든 주제의 ‘개념’ 모델이다. (비즈니스 도메인 객체)</li>
  <li>소프트웨어 개발에서 시스템의 비즈니스 로직과 규칙을 표현하는 핵심 요소이다.</li>
</ul>

<h3 id="구성요소">구성요소</h3>
<ul>
  <li>엔티티 (Entity) : 고유 식별자 (ID)를 가진 객체로, 비즈니스의 주요 개념을 나타낸다.</li>
  <li>값 객체 (Value Object) : 식별자가 없고 불변인 객체로, 엔티티의 속성을 나타내는데 사용된다.</li>
  <li>어그리게이트(Aggregate) : 엔티티와 값 객체와 관련된 집합으로 하나의 루트 엔티티로 접근하여 일관성을 유지한다.</li>
  <li>리포지토리 (Repository) : 도메인 객체를 저장하고 검색하는데 사용되는 인터페이스이다.</li>
</ul>

<h3 id="구현">구현</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class User {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String nickname;

    private String email;

    public void signUp(String nickname) {
        this.nickname = nickname;
    }
}
</code></pre></div></div>
<ul>
  <li>도메인 모델의 예시이다.</li>
  <li>엔티티를 나타내며, 실제로 저장되는 컬럼 이외에도 컬럼 값을 조작하는 비즈니스 로직을 포함할 수 있다.</li>
</ul>

<h3 id="도메인-주도-설계-ddd">도메인 주도 설계 (DDD)</h3>
<ul>
  <li>도메인 주도 설계(Domain-Driven Design)은 도메인의 개념을 중심으로 하여 소프트웨어를 설계하는 방법론이다.</li>
  <li>복잡한 시스템을 개발하는 경우 도메인의 본질을 최대한 반영하여 모델을 설계하고 구현한다.</li>
  <li>복잡한 도메인을 이해하고, 도메인에 집중하여 효과적으로 모델링하기 위해 사용된다.</li>
</ul>

<p><br /></p>

<h2 id="repository">Repository</h2>

<h3 id="리포지토리">리포지토리</h3>
<ul>
  <li>도메인 객체의 영속성을 관리하는 역할을 담당한다.</li>
  <li>데이터베이스와 같은 영속성 저장소에 대한 접근을 캡슐화하고, 도메인 객체를 CRUD(Create, Read, Update, Delete)하는 메서드를 제공한다.</li>
  <li>도메인 모델과 데이터 접근 로직을 분리할 수 있도록 한다.</li>
</ul>

<h3 id="구성-요소">구성 요소</h3>
<ul>
  <li>인터페이스(Interface) : 리포지토리가 제공해야하는 메서드를 정의한다.</li>
  <li>구현 클래스(Implemention Class) : 인터페이스를 구현하여 실제 데이터베이스 접근 로직을 포함한다.</li>
</ul>

<h3 id="구현-1">구현</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    Optional&lt;User&gt; findAllByNickname(String nickname);
    Optional&lt;User&gt; findByEmail(String email);
}
</code></pre></div></div>
<ul>
  <li>Spring Data JPA는 JpaRepository인터페이스를 통해 기본적인 CRUD 메서드를 자동으로 제공한다.</li>
  <li>추가적인 커스텀 쿼리 메서드는 위의 코드와 같이 정의하여 사용할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="service">Service</h2>

<h3 id="서비스">서비스</h3>
<ul>
  <li>소프트웨어 시스템 내에서 특정 작업이나 기능을 수행하는데 중점을 둔 설계 요소이다.</li>
  <li>서비스에서 시스템의 핵심 비즈니스 로직을 구현한다.</li>
  <li>일반적으로 엔티티에 포함되지 않는 복잡한 비즈니스 로직을 캡슐화한다. 이를 통해 외부 시스템과의 통신과 같은 작업을 수행할 수 있다.</li>
  <li>특정 기능을 모듈화하여 코드의 가독성과 유지보수성을 향상시킨다.</li>
</ul>

<h3 id="유형">유형</h3>
<ul>
  <li>애플리케이션 서비스 : 사용자 인터페이스와 도메인 모델 사이의 조정 역할을 한다.</li>
  <li>도메인 서비스 : 도메인 로직을 캡슐화하며, 특정 엔티티에 국한되지 않는 비즈니스 로직을 구현한다. 여러 엔티티에 걸친 로직이나 엔티티 간의 상호작용을 처리한다.</li>
  <li>인프라스트럭쳐 서비스 : 데이터베이스 접근, 메시징, 로깅와 같은 인프라 관련 작업을 처리한다.</li>
</ul>

<h3 id="구현-2">구현</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class UserService {
    private final UserRepository userRepository;

    @Transactional
    public void signUp(
            UserSignupRequest userSignupRequest,
            HttpServletResponse response,
            AuthUser authUser) {
        User user = findUser(authUser);
        user.signUp(userSignupRequest.nickname());
    }

    public void logout(String accessToken, AuthUser authUser) {
        User user = findUser(authUser);
        user.logout();
    }

    public List&lt;UserNicknameResponse&gt; search(String nickname) {
        List&lt;User&gt; users = userRepository.findByNicknameContaining(nickname);
        return users.stream()
                .map(user -&gt; UserNicknameResponse.from(user))
                .toList();
    }

    private User findUser(AuthUser authUser) {
        return userRepository.findById(authUser.getId())
                .orElseThrow(() -&gt; new BusinessException(UserErrorCode.USER_NOT_FOUND));
    }
}
</code></pre></div></div>
<ul>
  <li>도메인 로직을 캡슐화하고, 사용자 관련된 책임을 명확히 분리하여 비즈니스 로직을 구현한다.</li>
  <li>서비스 계층으로 분리하고, 모듈화를 통해 유지보수성을 향상시킨다.</li>
</ul>

<p><br /></p>

<h2 id="controller">Controller</h2>

<h3 id="컨트롤러">컨트롤러</h3>
<ul>
  <li>소프트웨어 아키텍처에서 사용자의 요청을 처리하고, 응답을 생성하는 역할을 담당하는 컴포넌트이다.</li>
  <li>모델과 뷰를 연결하여 사용자 인터페이스와 도메인 로직 간의 상호작용을 관리한다.</li>
</ul>

<h3 id="주요-역할">주요 역할</h3>
<ol>
  <li>요청처리 : 사용자의 입력 (HTTP 요청)을 수신하고 이를 처리한다. URL매핑을 통해 적절한 컨트롤러 메서드가 호출된다.</li>
  <li>비즈니스 로직 호출 : 서비스 계층을 호출하여 필요한 비즈니스 로직을 실행한다. 컨트롤러에선 비즈니스 로직을 포함하지 않고 모두 서비스 계층에 위임한다.</li>
  <li>모델 업데이트 : 서비스를 통해 생성된 결과를 받아 데이터를 포함한 모델을 업데이트 한다.</li>
  <li>응답 생성 : JSON, HTML, XML 등 다양한 형식으로 사용자가 볼 수 있는 응답을 생성한다.</li>
</ol>

<h3 id="구현-3">구현</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class UserController {
    private final UserService userService;

    @PostMapping(value = "/sign-up",
            consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity&lt;Void&gt; signUp(
            @RequestPart MultipartFile image,
            @RequestPart UserSignupJsonRequest request,
            @AuthenticationPrincipal AuthUser authUser,
            HttpServletResponse response
    ) {

        UserSignupRequest userSignupRequest = UserSignupRequest.of(request, image);
        userService.signUp(userSignupRequest, response, authUser);

        return ResponseEntity.ok()
                .build();
    }

    @PostMapping("/logout")
    public ResponseEntity&lt;Void&gt; logout(
            @AuthenticationPrincipal AuthUser authUser,
            HttpServletRequest request
    ) {
        userService.logout(accessToken, authUser);

        return ResponseEntity.ok()
                .build();
    }
}
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@GetMapping</code>과 <code class="language-plaintext highlighter-rouge">@PostMapping</code> 등을 통해 HTTP 요청을 처리한다.</li>
  <li>서비스 계층의 메서드(비즈니스 로직)을 사용하고 결과를 응답받는다.</li>
  <li>응답을 생성하여 반환한다.</li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="Spring" /><category term="Spring" /><summary type="html"><![CDATA[웹 애플리케이션 계층 구조]]></summary></entry><entry><title type="html">(자바) 람다식 (Lambda)</title><link href="/jekyll-theme-yat/java/2024/06/07/(%EC%9E%90%EB%B0%94)-%EB%9E%8C%EB%8B%A4%EC%8B%9D-(Lambda).html" rel="alternate" type="text/html" title="(자바) 람다식 (Lambda)" /><published>2024-06-07T00:00:00+00:00</published><updated>2024-06-07T00:00:00+00:00</updated><id>/jekyll-theme-yat/java/2024/06/07/(%EC%9E%90%EB%B0%94)-%EB%9E%8C%EB%8B%A4%EC%8B%9D-(Lambda)</id><content type="html" xml:base="/jekyll-theme-yat/java/2024/06/07/(%EC%9E%90%EB%B0%94)-%EB%9E%8C%EB%8B%A4%EC%8B%9D-(Lambda).html"><![CDATA[<h3 id="람다식이란">람다식이란?</h3>
<ul>
  <li>익명함수 : 메서드의 이름과 반환값이 없이 간략하게 표현한 함</li>
  <li>Java 8에서 도입된 기능으로, 익명함수를 간결하게 표현하는 방법이다.</li>
  <li>람다식을 통해 코드를 더 간결하고 가독성 높게 작성할 수 있다.</li>
  <li>
    <p>기본 형태</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parameters) -&gt; expression
// 또는
(parameters) -&gt; { statements; }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="구성-요소">구성 요소</h3>
<ol>
  <li>파라미터 리스트 : 람다식이 사용할 파라미터들이다 메서드의 파라미터와 유사하다. 괄호 안에 파라미터를 표현한다.</li>
  <li>화살표 연산자 <code class="language-plaintext highlighter-rouge">-&gt;</code>: 람다식의 파라미터와 본문을 구분한다.</li>
  <li>본문 : 람다식이 실행할 코드이다. 표현식 또는 블록으로 구성될 수 있다.</li>
</ol>

<h3 id="예제">예제</h3>
<ol>
  <li>매개변수가 없고, 본문이 단일 표현식인 경우
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Runnable r = () -&gt; System.out.println("Hello, world!");
r.run();
</code></pre></div>    </div>
  </li>
  <li>매개변수가 있는 경우
```
// 매개변수가 하나인 경우
Consumer<String> consumer = (String s) -&gt; System.out.println(s);
consumer.accept("Hello, world!");</String></li>
</ol>

<p>// 매개변수의 타입을 생략한 경우
Consumer<String> consumer2 = s -&gt; System.out.println(s);
consumer2.accept("Hello, world!");</String></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
3. 매개변수가 여러개인 경우
</code></pre></div></div>
<p>BiFunction&lt;Integer, Integer, Integer&gt; sum = (a, b) -&gt; a + b;
int result = sum.apply(5, 3);
System.out.println(result);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
4. 본문이 여러 줄인 경우
</code></pre></div></div>
<p>BiFunction&lt;Integer, Integer, Integer&gt; max = (a, b) -&gt; {
    if (a &gt; b) {
        return a;
    } else {
        return b;
    }
};
int maxValue = max.apply(5, 3);
System.out.println(maxValue);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 함수형 인터페이스
- 함수형 인터페이스 : 단 하나의 추상 메서드만 가지는 인터페이스, `@FunctionalInterface`르르 사용하여 함수형 인터페이스임을 명시할 수 있다.
- 람다식은 함수형 인터페이스의 인스턴스를 생성할 때 사용된다.
- java.util.funcion 패키지 : 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓은 패키지이다. 새로운 함수형 인터페이스를 정의하지 않고, 이 패키지의 인터페이스를 활용하여 재사용성을 높일 수 있다.

**주요 함수형 인터페이스**
|함수형 인터페이스|메서드|반환타입|설명|
|------|---|---|---|
|Consumer&lt;T&gt;|accept\(T t)|void|입력을 받아서 처리하는 함수. 반환값이 없음|
|Supplier&lt;T&gt;|get\()|T|입력 없이 출력을 생성하는 함수|
|Function&lt;T, R&gt;|apply\(T t)|R|입력을 받아서 출력을 반환하는 함수|
|Predicate&lt;T&gt;|test\(T t)|boolean|입력을 받아서 boolean 값을 반환하는 함수|
|BiFunction&lt;T, U, R&gt;|apply\(T t, U u)|R|두 개의 입력을 받아서 출력을 반환하는 함수|

### 스프링 MVC에서 람다식 활용 예제
**Entity**
</code></pre></div></div>
<p>@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private int age;
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
**Repository**
</code></pre></div></div>
<p>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    List<User> findByName(String name);
}</User></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
**Service**
</code></pre></div></div>
<p>@Service
public class UserService {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Autowired
private UserRepository userRepository;

public List&lt;User&gt; getUsersByName(String name) {
    return userRepository.findByName(name);
}

public List&lt;String&gt; getUserNamesByAge(int age) {
    List&lt;User&gt; users = (List&lt;User&gt;) userRepository.findAll();
    return users.stream()
                .filter(user -&gt; user.getAge() &gt; age)
                .map(User::getName)
                .collect(Collectors.toList());
} } ``` - users 리스트를 stream()으로 처리할 때 filter()를 통해 각 user 요소의 age 값이 매개변수 age값보다 큰 경우만을 거르는 조건을 람다식으로 처리하였다.
</code></pre></div></div>]]></content><author><name>Yun Daehyun</name></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[람다식이란? 익명함수 : 메서드의 이름과 반환값이 없이 간략하게 표현한 함 Java 8에서 도입된 기능으로, 익명함수를 간결하게 표현하는 방법이다. 람다식을 통해 코드를 더 간결하고 가독성 높게 작성할 수 있다. 기본 형태]]></summary></entry><entry><title type="html">(자바) 스트림 (Stream)</title><link href="/jekyll-theme-yat/java/2024/06/04/(%EC%9E%90%EB%B0%94)-%EC%8A%A4%ED%8A%B8%EB%A6%BC-(Stream).html" rel="alternate" type="text/html" title="(자바) 스트림 (Stream)" /><published>2024-06-04T00:00:00+00:00</published><updated>2024-06-04T00:00:00+00:00</updated><id>/jekyll-theme-yat/java/2024/06/04/(%EC%9E%90%EB%B0%94)-%EC%8A%A4%ED%8A%B8%EB%A6%BC-(Stream)</id><content type="html" xml:base="/jekyll-theme-yat/java/2024/06/04/(%EC%9E%90%EB%B0%94)-%EC%8A%A4%ED%8A%B8%EB%A6%BC-(Stream).html"><![CDATA[<h3 id="개념">개념</h3>
<ul>
  <li>Java 8부터 추가된 기능으로 컬렉션, 배열과 같은 다양한 데이터 소스를 추상화하여 일련의 계산을 표현한다.</li>
  <li>스트림을 사용하여 데이터를 필터링, 매핑, 집계하는 등의 작업을 더 간결하고 선언적으로 표현할 수 있다.</li>
</ul>

<h3 id="특징">특징</h3>
<ul>
  <li>선언전 방식 : 처리하는 방식보다 처리할 데이터에 집중할 수 있다.</li>
  <li>파이프라이닝 : 체이닝을 통해 연결할 수 있고, 중간 연산과 최종 연산으로 나뉜다.</li>
  <li>내부 반복 : 내부적으로 반복을 처리하여 더 나을 성능과 코드 가독성을 제공한다.</li>
  <li>불변성 : 원본 데이터를 변경하지 않고, 결과만을 반환한다.</li>
  <li>지연 평가 : 중간 연산은 지연평가를 수행하여 실제로 필요한 시점에만 계산을 수행한다.</li>
</ul>

<h3 id="구성">구성</h3>
<ul>
  <li>스트림 연산은 생성 -&gt; 중간 연산 -&gt; 최종 연산 순으로 구성된다.</li>
</ul>

<p><strong>1. 생성</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; list = Arrays.asList("a", "b", "c");
Stream&lt;String&gt; stream = list.stream();
</code></pre></div></div>
<ul>
  <li>stream() 메서드를 통해 스트림을 생성한다.</li>
</ul>

<p><strong>2. 중간 연산</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; result = list.stream()
    .filter(s -&gt; s.startsWith("a"))  // 필터링
    .map(String::toUpperCase)        // 매핑
    .sorted()                        // 정렬
    .toList();                       // 최종 연산이 호출될 때까지 실제로 실행되지 않음
</code></pre></div></div>
<ul>
  <li>중간 연산은 스트림을 변환하지만 최종결과를 반환하지 않는다.</li>
  <li>이러한 연산은 지연 평가된다.</li>
  <li>중간 연산 메서드
    <ul>
      <li>filter(Predicate<T> predicate): 조건에 맞는 요소만 필터링한다. if 문 역할을 한다.</T></li>
      <li>map(Function&lt;T, R&gt; mapper): 각 요소를 특정 값으로 변환한다. 람다를 인자로 받아. 스트림을 원하는 모양의 새로운 스트림으로 변환할 때 사용한다.</li>
      <li>flatMap(Function&lt;T, Stream<R>&gt; mapper): 중첩된 스트림을 평면화한다.</R></li>
      <li>sorted(): 스트램 내 요소들을 정렬한다. 정렬 조건으로 Comparator를 사용한다.</li>
      <li>distinct(): 스트림 내 중복을 제거한다.</li>
      <li>limit(long maxSize): 스트림의 크기를 제한한다.</li>
      <li>skip(long n): 처음 n개의 요소 건너뛴다.</li>
    </ul>
  </li>
</ul>

<p><strong>3. 최종 연산</strong></p>
<ul>
  <li>스트림은 최종 연산을 통해 데이터를 처리하고, 결과를 도출한다.</li>
</ul>

<p>① 계산(Calculaing) : 기본 형 타입을 사용하는 경우 스트림 내 요소들로 최소, 최대, 합, 평균 등을 계산하여 결과를 도출할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntStream stream = list.stream();
// 스트림 요소 개수 반환
long count = stream.count();
// 스트림 요소의 합 반환
int sum = stream.sum();
// 스트림의 최소값 반환
OptionalInt min = stream.min();
// 스트림의 최대값 반환
OptionalInt max = stream.max();
// 스트림의 평균값 반환
OptionalDouble average = stream.average();
</code></pre></div></div>

<p>② 축소 (Reduction) : 스트림의 요소를 하나씩 줄여가며 누적 연산을 수행한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntStream stream = IntStream.range(1, 5);
int result = stream.reduce(10, (total, num) -&gt; total + num);
// 10 + 1 + 2 + 3 + 4 = 20
</code></pre></div></div>

<p>③ 수집 (Collecting) : 스트림의 요소를 원하는 자료형으로 변환한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// toList() - 리스트로 반환
List&lt;String&gt; lastNames = members.stream()
    .map(Person::getLastName)
    .collect(Collectors.toList());

// joining() - 작업 결과를 하나의 스트링으로 이어 붙이기
String names = members.stream()
    .map(Person::getLastName)
    .collect(Collectors.joining("+", "&lt;", "&gt;"));

// groupingBy() - 그룹 지어서 Map으로 반환
Map&lt;Integer, List&lt;Person&gt;&gt; groupedByAge = members.stream()
    .collect(Collectors.groupingBy(Person::getAge));

// collectingAndThen() - 수집한 결과를 변환
Set&lt;Person&gt; unmodifiableSet = members.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.toSet(),
        Collections::unmodifiableSet
    ));
</code></pre></div></div>

<p>④ 매칭 (Matching) : 특정 조건을 만족하는 요소가 있는 체크한다. 만족하면 true, 만족하지 않으면 false를 반환한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; members = Arrays.asList("Lee", "Park", "Hwang");

// 하나라도 만족하는 요소가 있는지
boolean anyMatch = members.stream()
    .anyMatch(member -&gt; member.contains("w")); // true

// 모든 요소가 조건을 만족하는지
boolean allMatch = members.stream()
    .allMatch(member -&gt; member.length() &gt;= 4); // false

// 모든 요소가 조건을 만족하지 않는지
boolean noneMatch = members.stream()
    .noneMatch(member -&gt; member.endsWith("t")); // true
</code></pre></div></div>

<p>⑤ 반복 (Iterating) : 스트림의 각 요소를 돌며 인수에 대한 작업을 수행한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>members.stream()
    .map(Person::getName)
    .forEach(System.out::println);
</code></pre></div></div>

<p>⑥ 찾기 (Finding) : 스트림에서 하나의 요소만을 찾아 반환한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person person1 = members.stream()
    .findAny(); // 병렬 스트림의 경우 첫 번째 요소가 보장되지 않음

Person person2 = members.stream()
    .findFirst(); // 첫 번째 요소 반환
</code></pre></div></div>]]></content><author><name>Yun Daehyun</name></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[개념 Java 8부터 추가된 기능으로 컬렉션, 배열과 같은 다양한 데이터 소스를 추상화하여 일련의 계산을 표현한다. 스트림을 사용하여 데이터를 필터링, 매핑, 집계하는 등의 작업을 더 간결하고 선언적으로 표현할 수 있다.]]></summary></entry><entry><title type="html">(디자인 패턴) 정적 팩토리 메서드 패턴</title><link href="/jekyll-theme-yat/designpattern/2024/06/01/(%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4.html" rel="alternate" type="text/html" title="(디자인 패턴) 정적 팩토리 메서드 패턴" /><published>2024-06-01T00:00:00+00:00</published><updated>2024-06-01T00:00:00+00:00</updated><id>/jekyll-theme-yat/designpattern/2024/06/01/(%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4</id><content type="html" xml:base="/jekyll-theme-yat/designpattern/2024/06/01/(%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4.html"><![CDATA[<h2 id="팩토리-메서드-패턴">팩토리 메서드 패턴</h2>

<h3 id="개념">개념</h3>
<ul>
  <li>객체 생성의 책임을 메서드에 위임하는 디자인 패턴</li>
  <li>일반 생성자 대신 정적 메서드를 통해 객체를 생성하고, 객체 생성에 대한 더 많은 제어 및 로직과 유연성을 제공하여 다양한 형태로 객체 생성이 가능하다.</li>
</ul>

<h3 id="예시-코드">예시 코드</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Car {
    private String name;
    
    // 생성자를 private로 선언하여 외부에서 생성자 호출 불가
    private Car(String name) { this.name = name; }
    
    // 정적 팩토리 메서드
    public static Car from(String title) {
        return new Car(name);
    }
}
</code></pre></div></div>
<ul>
  <li>생성자를 private으로 선언하여 외부에서 생성자를 통한 인스턴스 생성을 막는다.</li>
  <li>메서드를 통해 객체를 생성하여 메서드의 생성 관련 로직을 추가하여 유연한 객체 생성을 할 수 있도록 한다.</li>
</ul>

<h3 id="특징">특징</h3>
<p><strong>1. 메서드 명을 통해 생성 목적을 나타낼 수 있다.</strong></p>

<p>생성 목적에 따라 생성자를 오버로딩하는 방식을 통해 다양한 형태로 구분할 순 있지만, 생성자의 특징을 구분할 순 없다. 그래서 개발자는 생성자를 통해 객체를 생성하려면 인자 순서 및 내부 구조를 알고 있어야 목적에 맞게 객체를 생성할 수 있다. 따라서, 매개변수만으로는 객체의 특성을 구분할 수 없다.
반면, 메서드는 이름을 가지고 있기 때문에 각 메서드에 생성된 객체의 특성에 맞는 이름을 부여해주어 코드의 가독성을 높일 수 있다.
<br /></p>

<p><strong>2. 다양한 객체를 반환할 수 있다.</strong></p>

<p>같은 타입의 객체를 반환하는 여러 정적 메서드를 제공할 수 있다. 메서드의 유연성을 통해 조건에 따라 반환되는 객체의 형태를 달리할 수 있다.
일반적으로 인자를 받아 인자의 따라 분기문을 통해 여러 타입의 인스턴스를 반환하도록 구성이 가능하다.
<br /></p>

<p><strong>3. 미리 인스턴스를 생성하여 반환할 수 있다.</strong></p>

<p>인스턴스를 미리 생성하고, 이를 공유하여 재사용하게 하여 불필요한 객체를 생성하는 것을 방지할 수 있다.
동일한 객체를 캐싱하여 반환하고, 이는 불변 객체의 경우에 특히 더 유용하다.
<br /></p>

<p><strong>4. 서브타입의 객체를 반환할 수 있다.</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface Animal {}

public class Dog implements Animal {}

public class Cat implements Animal {}

public class AnimalFactory {
    public static Animal createAnimal(String type) {
        if (type.equals("Dog")) {
            return new Dog();
        } else if (type.equals("Cat")) {
            return new Cat();
        } else {
            throw new IllegalArgumentException("Unknown animal type");
        }
    }
}
</code></pre></div></div>
<p>매서드 호출을 통해 반환할 객체의 인스턴스가 하위타입의 인스턴스가 될 수 있어 유연성을 가진다.</p>

<p><strong>5. 객체 생성을 캡슐화 할 수 있다.</strong></p>

<p>생성자를 통해 객체 생성의 경우 외부에 내부 구현을 드러내야하는 것에 반해 정적 팩토리 메서드를 통한 객체 생성의 경우 구현부를 외부로부터 숨길 수 있다. 이러한 특징으로 정보 은닉성을 가진다.</p>

<h3 id="네이밍-규칙">네이밍 규칙</h3>
<ul>
  <li>메서드의 역할을 이름을 통해 쉽게 구분하기 위해서 독자적인 네이밍 컨벤션 (Naming Convetion)이 존재한다. 이는 통상적으로 개발자들간의 규칙처럼 사용된다.</li>
</ul>

<p>(1) from : 하나의 매개변수를 받아 해당 타입의 인스턴스를 반환하는 경우</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public record ExampleResponse(
        Long id,
        String name
) {
    public static ExampleResponse from (Example example) {
        return new ExampleResponse(example.getId(), example.getName());
    }
}
</code></pre></div></div>

<p>(2) of : 여러개의 매개변수 받아 적절한 타입의 인스턴스를 반환하는 경우</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public record Animal(
        String name
) {
    public static Animal from (String name, String type) {
        if (type.equals("Dog")) {
          return new Dog(name);
        } else if (type.equals("Cat")) {
          return new Cat(name);
        }
    }
}
</code></pre></div></div>

<p>(3) valueOf : from과 of 대신 통합하여 사용</p>

<p>(4) instance 또는 getInstance : 인스턴스를 반환하지만, 동일한 인스턴스가 반환된다는 보장은 없음</p>

<p>(5) create 또는 newInstance : 매번 새로운 인스턴스를 반환하는 경우</p>

<p>(6) getType : 팩토리 클래스와 다른 클래스의 인스턴스를 반환하는 경우</p>

<p>(7) newType : 팩토리 클래스와 다른 클래스의 새로운 인스턴스를 반환하는 경우</p>]]></content><author><name>Yun Daehyun</name></author><category term="DesignPattern" /><category term="Java" /><category term="DesignPattern" /><summary type="html"><![CDATA[팩토리 메서드 패턴]]></summary></entry><entry><title type="html">(OAuth2 Login) 구글 소셜 로그인 구현 (1) - 동작원리</title><link href="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(1)-_-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC.html" rel="alternate" type="text/html" title="(OAuth2 Login) 구글 소셜 로그인 구현 (1) - 동작원리" /><published>2024-04-18T00:00:00+00:00</published><updated>2024-04-18T00:00:00+00:00</updated><id>/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(1)-_-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC</id><content type="html" xml:base="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(1)-_-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC.html"><![CDATA[<h2 id="개요">개요</h2>
<h3 id="oauth2란">OAuth2란?</h3>
<ul>
  <li>Google, Naver, Kakao와 같이 신뢰할 수 있는 어플리케이션의 Open API와 통신하여 해당 어플리케이션이 대신 사용자의 인증을 처리하여 로그인 서비스를 이용할 수 있도록 해주는 방식이다.</li>
</ul>

<h3 id="사전-준비">사전 준비</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/bef9c10b-8a07-4ab7-8102-9001d0f799f0" alt="image" /></p>

<ul>
  <li>Google의 OAuth2를 이용할 것이기 때문에 Google Cloud Platform에 API 및 서비스를 등록하여야한다.</li>
  <li>위 그림과 같이 OAuth 2.0 클라이언트 ID를 생성한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/66b29f3b-b4a8-485a-90af-e1c3f834fd82" alt="image" /></p>

<ul>
  <li>위 그림과 같이 URI를 등록한다. 로컬과 EC2서버의 요청에 모두 응답할 수 있도록 여러 URI를 등록하였다.</li>
</ul>

<p><br />
<br />
<br /></p>

<h2 id="oauth2-로그인-동작과정">OAuth2 로그인 동작과정</h2>
<h3 id="과정-그림">과정 그림</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/7b61fafa-7517-4f62-b489-be5c72c8a705" alt="image" /></p>

<h3 id="과정-설명">과정 설명</h3>
<ol>
  <li>웹(클라이언트)에서 하이퍼 링크로 백엔드(서버)에 GET 요청을 보낸다.</li>
  <li>백엔드에서 Google 인증 서버로 로그인 요청 로직을 보낸다.</li>
  <li>Google 인증 서버에서 로그인 페이지를 웹에 제공한다.</li>
  <li>사용자는 로그인 페이지에서 로그인을 진행하여 Google 인증 서버에 로그인 정보를 보낸다.</li>
  <li>Google 인증 서버는 웹에게 권한을 승인했다는 임시 비밀번호 역할을 하는 Authorization Code를 발급한다.</li>
  <li>클라이언트는 Redirect URL 경로에 Authrization Code를 담아 백엔드에 보낸다.</li>
  <li>백엔드는 Google 인증 서버에 Access Token을 요청하기 위해서 전달받은 Redirect URL의 Authorization Code를 함께 보낸다.</li>
  <li>Google 인증 서버에서 받은 URL의 정보들과 Google 인증 서버가 가진 정보가 일치하면 Access Token을 발급하여 Http response를 통해 백엔드에 전달한다. 이때, Authorizaion code는 삭제된다.</li>
  <li>만약, Refresh Token을 함께 전달받았다면 DB에 Refresh Token을 저장하고, 로그인 성공 로직이 수행된다.</li>
  <li>로그인된 사용자가 가진 Access Token로 백엔드에 서비스를 요청한다.</li>
  <li>백엔드에선 해당 Access Token으로 Google API 서버에 사용자 정보를 요청한다.</li>
  <li>Google API 서버는 Access Token을 검증하고, 검증 완료되면 서비스를 제공한다.</li>
  <li>사용자는 서비스를 제공받는다.</li>
</ol>]]></content><author><name>Yun Daehyun</name></author><category term="OAuth2" /><category term="Spring" /><category term="Spring Security" /><category term="JWT" /><summary type="html"><![CDATA[개요 OAuth2란? Google, Naver, Kakao와 같이 신뢰할 수 있는 어플리케이션의 Open API와 통신하여 해당 어플리케이션이 대신 사용자의 인증을 처리하여 로그인 서비스를 이용할 수 있도록 해주는 방식이다.]]></summary></entry><entry><title type="html">(OAuth2 Login) 구글 소셜 로그인 구현 (2) - 도메인 생성</title><link href="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(2)-_-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%83%9D%EC%84%B1.html" rel="alternate" type="text/html" title="(OAuth2 Login) 구글 소셜 로그인 구현 (2) - 도메인 생성" /><published>2024-04-18T00:00:00+00:00</published><updated>2024-04-18T00:00:00+00:00</updated><id>/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(2)-_-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%83%9D%EC%84%B1</id><content type="html" xml:base="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(2)-_-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%83%9D%EC%84%B1.html"><![CDATA[<h2 id="도메인-생성">도메인 생성</h2>
<h3 id="basetime">BaseTime</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Getter
@Setter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseTime {
    @CreatedDate
    private LocalDateTime createdDate; // 생성시간

    @LastModifiedDate
    private LocalDateTime updatedDate; // 수정시간
}
</code></pre></div></div>
<ul>
  <li>User가 생성되거나 변경될 때의 시간을 추가적으로 저장하기 위해서 BaseTime을 생성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@CreateDate</code>로 User가 생성되는 시간을 나타내는 필드를 지정한다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">@LastModifiedDate</code>로 User가 변경되는 시간을 나타내는 필드를 지정한다.
```
@SpringBootApplication
@EnableJpaAuditing
public class AppApplication {</p>

    <p>public static void main(String[] args) {
      SpringApplication.run(AppApplication.class, args);
  }</p>
  </li>
</ul>

<p>}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- BaseTime을 적용하기 위해서는 AppApplication 클래스에 `@EnableJpaAuditing`을 추가해주어야한다.

&lt;br&gt;

### Role
</code></pre></div></div>
<p>@Getter
@RequiredArgsConstructor
public enum Role {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GUEST("ROLE_GUEST"), USER("ROLE_USER");

private final String key; } ``` - 회원가입(추가정보 입력)을 하지 않는 최초 로그인 사용자를 나타내는 GUEST와 이외의 로그인 사용자를 나타내는 USER를 구분하기 위해서 ENUM을 생성한다.
</code></pre></div></div>

<p><br /></p>

<h3 id="user-entity">User Entity</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
@AllArgsConstructor
public class User extends BaseTime {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String socialId;

    private String name;

    private String nickname;

    private String email;

    private String imageUrl;

    private String refreshToken;

    // 최초 로그인 구분, GUEST, USER
    @Enumerated(EnumType.STRING)
    private Role role;

    private String state;

    private String description;

    private String interest;

    public void authorizeUser() {
        this.role = Role.USER;
    }

    public void updateRefreshToken(String updateRefreshToken) {
        this.refreshToken = updateRefreshToken;
    }

    public void signUp(String nickname, String imageUrl) {
        this.nickname = nickname;
        this.imageUrl = imageUrl;
    }

    public void logout() {
        this.refreshToken = null;
    }
</code></pre></div></div>
<ul>
  <li>사용자의 정보를 가지고 있는 User Entity를 생성한다.</li>
  <li>role 필드를 통해 사용자를 구분한다.</li>
  <li>구글로부터 socialId, name, email을 받아와 저장한다.</li>
  <li>회원가입을 통해 imageUrl, nickname을 저장한다.</li>
  <li>refresh 토큰을 DB에 저장하기 위해서 refreshToken 필드를 추가한다.</li>
</ul>

<p><br /></p>

<h3 id="user-repository">User Repository</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    Optional&lt;User&gt; findBySocialId(String socialId);
    Optional&lt;User&gt; findByNickname(String nickname);
    Optional&lt;User&gt; findByRefreshToken(String refreshToken);
    Optional&lt;User&gt; findByEmail(String email);
}
</code></pre></div></div>
<ul>
  <li>찾을 사용자가 존재할 수도, 존재하지 않을 수도 있기 때문에 모든 메서드를 Optional<User>타입으로 선언하였다.</User></li>
  <li>다양한 필드를 통해 해당 USER를 찾을 수 있도록 메서드를 추가하였다.</li>
</ul>

<h3 id="user-dto">USER DTO</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public record UserSignupJsonRequest(String nickname) {
}
</code></pre></div></div>
<ul>
  <li>회원가입을 통해 사용자의 닉네임을 클라이언트로부터 받아오기 위해 UserSignupJsonRequest 레코드를 생성하였다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public record UserSignupRequest(
        String nickname,
        MultipartFile image
) {

    public static UserSignupRequest of(UserSignupJsonRequest request, MultipartFile image) {
        return new UserSignupRequest(request.nickname(), image);
    }
}
</code></pre></div></div>
<ul>
  <li>회원가입을 통해 사용자의 닉네임 정보를 담은 UserSignupJsonRequest 객체와 이미지를 받아 인스턴스를 생성하는 UserSignupRequest 레코드를 생성하였다.</li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="OAuth2" /><category term="Spring" /><category term="Spring Security" /><category term="JWT" /><summary type="html"><![CDATA[도메인 생성 BaseTime ``` @Getter @Setter @MappedSuperclass @EntityListeners(AuditingEntityListener.class) public abstract class BaseTime { @CreatedDate private LocalDateTime createdDate; // 생성시간]]></summary></entry><entry><title type="html">(OAuth2 Login) 구글 소셜 로그인 구현 (3) - JWT 인증</title><link href="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(3)-_-JWT-%EC%9D%B8%EC%A6%9D.html" rel="alternate" type="text/html" title="(OAuth2 Login) 구글 소셜 로그인 구현 (3) - JWT 인증" /><published>2024-04-18T00:00:00+00:00</published><updated>2024-04-18T00:00:00+00:00</updated><id>/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(3)-_-JWT-%EC%9D%B8%EC%A6%9D</id><content type="html" xml:base="/jekyll-theme-yat/oauth2/2024/04/18/(OAuth2-Login)-%EA%B5%AC%EA%B8%80-%EC%86%8C%EC%85%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84-(3)-_-JWT-%EC%9D%B8%EC%A6%9D.html"><![CDATA[<h2 id="jwt">JWT</h2>
<h3 id="jwt란">JWT란?</h3>
<ul>
  <li>JSON Web Token의 약자로 인증에 필요한 정보들을 암호화한 JSON 토큰을 의미한다.</li>
  <li>토큰에는 사용자 관련 여러 정보가 포함되어있다.</li>
  <li>JWT를 통해 Stateless 하게 설계가 가능하다.</li>
</ul>

<h3 id="jwt-인증-순서">JWT 인증 순서</h3>
<ol>
  <li>사용자가 로그인 정보를 가지고 로그인을 서버에 요청한다.</li>
  <li>서버는 JWT 토큰을 생성하여 클라이언트에 보낸다.</li>
  <li>클라이언트는 받은 JWT 토큰을 사용하여 서비스 요청할 때마다 Http Header에 JWT를 넣어 서버에 요청한다.</li>
  <li>서버는 해당 JWT를 검증하고, 유효하다면 요청에 대한 응답을 반환한다.</li>
</ol>

<h3 id="jwt-구조">JWT 구조</h3>
<ul>
  <li>Header
    <ul>
      <li>토큰의 타입과 전자서명 알고리즘이 저장된다.</li>
    </ul>
  </li>
  <li>Payload
    <ul>
      <li>Claim운 토큰에서 사용하는 정보를 포함한다.</li>
      <li>Payload는 이러한 Claim을 여러개 포함한다.</li>
    </ul>
  </li>
  <li>Signature
    <ul>
      <li>header와 payload를 암호화한 것과 서버가 가지고 있는 개인 키를 암호화한 정보가 저장된다.</li>
    </ul>
  </li>
</ul>

<h3 id="access-token--refresh-token">Access Token &amp; Refresh Token</h3>
<ul>
  <li>Access Token
    <ul>
      <li>로그인 시 발급 받고, 인증 처리 위해 사용되는 토큰을 말한다.</li>
      <li>탈취 위험으로부터 벗어나기 위해 유효 기간을 짧게 설정한다.</li>
      <li>처음 로그인 요청 시 서버에서 Access Token을 발급하고, 클라이언트는 Http Header에 이를 저장하여 서비스를 이용하기 위해 요청마다 Access Token을 보낸다.</li>
    </ul>
  </li>
  <li>Refresh Token
    <ul>
      <li>유효시간이 짧은 Access Token으로 인한 trade-off 문제를 해결하기 위한 토큰</li>
      <li>DB와 같은 저장소에서 저장되어 Access Token을 재발급 해주는 토큰을 말한다.</li>
      <li>처음 로그인 요청시 서버에서 Access Token과 함께 Refresh Token을 발급하는데 Refresh Token은 Http Header에 저장되지 않고, 서버 DB에 저장된다.</li>
      <li>Refresh Token은 자체적으로 인증 용도로 사용되지 않고, Access Token을 재발급하기 위한 용도로만 사용된다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="jwt-구현">JWT 구현</h2>
<ul>
  <li>Access 토큰과 Refresh 토큰을 모두 사용한다.</li>
  <li>Access 토큰은 HTTP Header에 저장하고, Refresh 토큰은 쿠키에 저장한다.</li>
</ul>

<h3 id="의존성-추가-및-jwt-설정">의존성 추가 및 JWT 설정</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
  ...

	//JWT
	implementation 'com.auth0:java-jwt:4.2.1'

  ...
}
</code></pre></div></div>
<ul>
  <li>JWT를 사용하기 위해 build.gradle에 위 코드를 추가한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jwt:
  secretKey: 'qwjedi19hrb18odxkcnwgkjkladhnw9182nmsd0s89y12mne123mksnsaujfdhowkrn3k45786zxnmcvwjehrkeljhfjwh1'

  access:
    expiration: 3600000 # 1시간 30분
    header: Authorization

  refresh:
    expiration: 1209600000 # 2주
    header: Authorization-refresh
</code></pre></div></div>
<ul>
  <li>application.yml에 jwt의 비밀키와 access 토큰과 refresh 토큰의 만료 시간 및 header 이름을 설정한다.</li>
</ul>

<h3 id="jwt-생성-서비스">JWT 생성 서비스</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Service
@RequiredArgsConstructor
@Getter
@Slf4j
public class JwtCreateAndUpdateService {
    @Value("${jwt.secretKey}")
    private String secretKey; //jwt 비밀키

    @Value("${jwt.access.expiration}")
    private Long accessTokenExpirationPeriod; // access 토큰 유효 시간

    @Value("${jwt.refresh.expiration}")
    private Long refreshTokenExpirationPeriod; // refresh 토큰 유효 시간

    private static final String ACCESS_TOKEN_SUBJECT = "AccessToken";
    private static final String REFRESH_TOKEN_SUBJECT = "RefreshToken";
    private static final String EMAIL_CLAIM = "email";
    private final UserRepository userRepository;
    private final RedisUtil redisUtil;

    //access 토큰 생성
    public String createAccessToken(String email) {
        Date now = new Date(); // 현재 시간

        return JWT.create() // JWT 토큰 생성 빌더 반환
                .withSubject(ACCESS_TOKEN_SUBJECT) //JWT subject를 access 토큰으로 설정
                .withExpiresAt(new Date(now.getTime() + accessTokenExpirationPeriod)) // 토큰 만료 시간을 access 토큰 유효시간으로 설정
                .withClaim(EMAIL_CLAIM, email) // 클레임을 이메일 값으로 설정
                .sign(Algorithm.HMAC512(secretKey)); //HMAC512 알고리즘을 사용하여 secret키로 암호화하여 access 토큰 생성
    }

    //refresh 토큰 생성
    //대부분 access 토큰 생성과정과 동일하지만 클레임에 이메일 설정 X
    public String createRefreshToken() {
        Date now = new Date();
        return JWT.create()
                .withSubject(REFRESH_TOKEN_SUBJECT)
                .withExpiresAt(new Date(now.getTime() + refreshTokenExpirationPeriod))
                .sign(Algorithm.HMAC512((secretKey)));
    }

    //RefreshToken을 DB에 업데이트
    public void updateRefreshToken(String email, String refreshToken) {
        userRepository.findByEmail(email)
                .ifPresentOrElse(
                        user -&gt; user.updateRefreshToken(refreshToken), //회원이 존재하면 refresh 토큰 업데이트
                        () -&gt; new IllegalStateException("일치하는 회원이 없습니다.") //회원이 존재하지 않으면 exception 발생
                );
    }

    public Long getRemainingExpirationTime(String accessToken) {
        Long expiration = JWT.decode(accessToken).getExpiresAt().getTime();
        Long now = new Date().getTime();

        return (expiration - now);
    }

    //토큰 유효성 검사
    public boolean isTokenValid(String token) {
        try {
            JWT.require(Algorithm.HMAC512(secretKey)).build().verify(token);
            if (redisUtil.hasKeyBlackList(token)) {
                throw new RuntimeException("토그아웃 상태의 토큰입니다.");
            }
            return true;
        } catch (Exception e) {
            log.error("유효하지 않은 토큰입니다. {}", e.getMessage());
            return false;
        }
    }
}
</code></pre></div></div>
<ul>
  <li>JWT 토큰을 생성하기 위한 서비스를 구현한다.</li>
  <li><code class="language-plaintext highlighter-rouge">createAccessToken()</code> : Access 토큰을 생성하는 메서드이다. 클레임을 이메일 값으로 설정하기 위해서 이메일을 매개변수로 받는다.</li>
  <li><code class="language-plaintext highlighter-rouge">createRefreshToken()</code> : Refresh 토큰을 생성하는 메서드이다. 클레임에 이메일을 설정하지 않는다.</li>
  <li><code class="language-plaintext highlighter-rouge">updateRefreshToekn()</code> : Refresh 토큰을 DB에 저장하는 메서드이다.</li>
  <li><code class="language-plaintext highlighter-rouge">getRemainingExpirationTime()</code> : Access 토큰의 남은 만료시간을 반환한다. 로그아웃에 사용된다.</li>
  <li><code class="language-plaintext highlighter-rouge">isTokenValid()</code> : 토큰의 유효성을 검사한다. 나중에 다시 얘기하겠지만 Redis에 토큰이 저장되어있는 경우 로그아웃 상태의 토큰으로 인식되어 유효하지 않는 토큰으로 구분된다.</li>
</ul>

<h3 id="jwt-추출-서비스">JWT 추출 서비스</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Service
@RequiredArgsConstructor
@Getter
@Slf4j
public class JwtExtractService {
    @Value("${jwt.secretKey}")
    private String secretKey; //jwt 비밀키

    @Value("${jwt.access.header}")
    private String accessHeader; // access 헤더

    @Value("${jwt.refresh.header}")
    private String refreshHeader; // refresh 헤더

    private static final String EMAIL_CLAIM = "email";
    private static final String BEARER = "Bearer ";

    //클라이언트의 요청으로 access 토큰 header에서 추출
    public Optional&lt;String&gt; extractAccessToken(HttpServletRequest request) {
        return Optional.ofNullable(request.getHeader(accessHeader)) // 헤더의 accessHeader의 값 가져옴
                .filter(refreshToken -&gt; refreshToken.startsWith(BEARER)) //Bearer 로 시작하면 통과
                .map(refreshToken -&gt; refreshToken.replace(BEARER, "")); //'Bearer '부분을 삭제해 순수 토큰만 가져옴
    }

    //클라이언트 요청으로 refresh 토큰 header에서 추출
    public Optional&lt;String&gt; extractRefreshToken(HttpServletRequest request) {
        return Arrays.stream(request.getCookies())
                .filter(cookie -&gt; refreshHeader.equals(cookie.getName()))
                .map(Cookie::getValue)
                .findFirst();
    }

    //AccessToken에서 Email추출
    public Optional&lt;String&gt; extractEmail(String accessToken) {
        try {
            //require을 통해 secretKey를 사용하여 HMAC512알고리즘으로 토큰 유효성 검사 설정
            return Optional.ofNullable(JWT.require(Algorithm.HMAC512(secretKey))
                    .build() // 반환된 빌더로 JWT verifier 생성
                    .verify(accessToken) //access토큰을 검증하고 유효하지 않으면 예외 발생
                    .getClaim(EMAIL_CLAIM) // 이메일 가져옴
                    .asString()); //String 형식으로 가져옴
        } catch (Exception e) {
            log.error("Access Token이 유효하지 않습니다.");
            return Optional.empty(); //빈 Optional객체 반환
        }
    }
}
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">extractAccessToken()</code> : Http 헤더에서 access 토큰을 추출한다.</li>
  <li><code class="language-plaintext highlighter-rouge">extractRefreshToken()</code> : 쿠키에서 refresh 토큰을 추출한다.</li>
  <li><code class="language-plaintext highlighter-rouge">extractEmail()</code> : Access 토큰에서 email을 추출한다.</li>
</ul>

<h3 id="jwt-전송-서비스">JWT 전송 서비스</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Service
@RequiredArgsConstructor
@Getter
@Slf4j
public class JwtSendService {

    @Value("${jwt.access.header}")
    private String accessHeader; // access 헤더

    @Value("${jwt.refresh.header}")
    private String refreshHeader; // refresh 헤더

    //Http 헤더로 Access 토큰 보내기
    public void sendAccessToken(HttpServletResponse response, String accessToken) {
        response.setStatus(HttpServletResponse.SC_OK); // 성공 상태
        response.setHeader(accessHeader, accessToken); // Http 헤더에 accessHeader를 키로 access 토큰 저장
        log.info("Access Token : {}", accessToken);
    }

    //Http 헤더에 Access 토큰, 쿠키에 Refresh 토큰 저장하여 전송
    public void sendAccessAndRefreshToken(HttpServletResponse response, String accessToken, String refreshToken) {
        response.setStatus(HttpServletResponse.SC_OK); // 성공 상태
        response.setHeader(accessHeader, accessToken); // Http 헤더에 accessHeader를 키로 access 토큰 저장
        response.addCookie(createCookie(refreshHeader, refreshToken));
        log.info("Access Token : {}, Refresh Token : {}", accessToken, refreshToken);
    }

    private Cookie createCookie(String key, String value) {
        Cookie cookie = new Cookie(key, value);
        cookie.setMaxAge(14*24*60*60);
        cookie.setPath("/");
        cookie.setHttpOnly(true);

        return cookie;
    }
}
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">sendAccessToken()</code> : Http 헤더에 Access 토큰을 담아 보낸다.</li>
  <li><code class="language-plaintext highlighter-rouge">sendAccessAndRefreshToken()</code> : Http 헤더에 Access 토큰을 담고, 쿠키에 Refresh 토큰을 담아 전송한다.</li>
  <li><code class="language-plaintext highlighter-rouge">createCookie()</code> :  Refresh 토큰을 담은 쿠키를 생성하는 메서드이다.</li>
</ul>

<h3 id="사용자-인증-및-권한-부여-관리-클래스">사용자 인증 및 권한 부여 관리 클래스</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class AuthUser implements UserDetails {

    private final Long id;
    private final String email;
    private final Role role;

    public static AuthUser createAuthUser(User user) {
        return new AuthUser(user);
    }

    private AuthUser(User user) {
        email = user.getEmail();
        role = user.getRole();
        id = user.getId();
    }

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        Collection&lt;GrantedAuthority&gt; collection = new ArrayList&lt;&gt;();
        collection.add(() -&gt; role.getKey());
        return collection;
    }

    @Override
    public String getPassword() {
        return null;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public Long getId() {
        return id;
    }
}
</code></pre></div></div>
<ul>
  <li>Spring Security를 사용하여 사용자 인증 및 권한 부여를 관리하는 데 사용되는 사용자 세부 정보(UserDetails)를 구현한 클래스이다.</li>
</ul>

<h3 id="jwt-인증-필터">JWT 인증 필터</h3>
<ul>
  <li>JWT 서비스를 이용하여 JWT 인증 처리, 인증 실패, 토큰 재발급 등의 JWT 관련 기능을 수행하는 필터이다.</li>
  <li>JWT 인증 관련해서 다음 3가지 경우의 상황이 발생할 수 있다.
    <ol>
      <li>Access 토큰이 유효한 경우 - Refresh 토큰이 사용자 요청 쿠키에 없다면 인증에 성공한다.</li>
      <li>Access 토큰이 유효하지 않고, 사용자 요청 쿠키에 Refresh 토큰이 있는 경우 - DB에 Refresh 토큰과 비교하여 일치하면 Access 토큰 재발급한다. 그렇지 않다면 인증 실패로 처리한다.</li>
      <li>Access 토큰이 없거나 유효하지 않고, Refresh 토큰도 없거나 유효하지 않을 경우 - 인증 실패, 403 ERROR 발생</li>
    </ol>
  </li>
  <li>위 상황을 처리하는 인증 필터를 구현한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@RequiredArgsConstructor
@Slf4j
@Component
public class JwtAuthenticationProcessingFilter extends OncePerRequestFilter {

    private static final String NO_CHECK_URL = "/login"; // '/login'으로 들어오는 요청은 Filter사용 X

    private final JwtCreateAndUpdateService jwtCreateAndUpdateService;
    private final JwtExtractService jwtExtractService;
    private final JwtSendService jwtSendService;
    private final UserRepository userRepository;

    private GrantedAuthoritiesMapper authoritiesMapper = new NullAuthoritiesMapper();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        if (request.getRequestURI().equals(NO_CHECK_URL)) { // '/login'으으로 요청이 들어오면 다음 필터를 호출
            filterChain.doFilter(request, response);
            return;
        }

        String refreshToken = jwtExtractService.extractRefreshToken(request) //사용자 요청 header에서 refresh 토큰 추출
                .filter(jwtCreateAndUpdateService::isTokenValid) //토큰 유효성 검사
                .orElse(null); //토큰이 없거나 유효하지 않으면 null 반환

        // refresh토큰이 사용자 header에 존재, access 토큰이 없어서 refresh 토큰을 요청한 경우
        if (refreshToken != null) {
            checkRefreshTokenAndReIssueAccessToken(response, refreshToken); //refresh 토큰이 DB의 refresh토큰과 일치하는 경우 access 토큰 재발급
            return;
        }

        // refresh토큰이 사용자 header에 존재 X, access 토큰이 있는지, 유효한지 검사
        if (refreshToken == null) {
            checkAccessTokenAndAuthentication(request, response, filterChain);
        }
    }

    //refresh 토큰으로 DB에서 유저를 찾고, 유저가 있다면 access, refresh 토큰 재발급 후 DB 업데이트
    private void checkRefreshTokenAndReIssueAccessToken(HttpServletResponse response, String refreshToken) {
        userRepository.findByRefreshToken(refreshToken) //refresh 토큰으로 user 찾음
                .ifPresent(user -&gt; { // user가 존재하면
                    String reIssueRefreshToken = reIssueRefreshToken(user); // refresh 토큰 재발급, DB 업데이트
                    jwtSendService.sendAccessAndRefreshToken(response, jwtCreateAndUpdateService.createAccessToken(user.getEmail()), reIssueRefreshToken);
                    //header에 access 토큰과 refresh 토큰 담아 보냄
                });
    }

    //refresh 토큰 재발급 후 refresh 토큰 DB에 업데이트
    private String reIssueRefreshToken(User user) {
        String reIssuedRefreshToken = jwtCreateAndUpdateService.createRefreshToken();
        updateUserRefreshToken(user, reIssuedRefreshToken);
        return reIssuedRefreshToken;
    }

    //user의 refresh 토큰 업데이트 후 저장
    private void updateUserRefreshToken(User user, String reIssuedRefreshToken) {
        user.updateRefreshToken(reIssuedRefreshToken);
        userRepository.saveAndFlush(user);
    }


    // access 토큰 유효성 검사 및 인증 처리
    private void checkAccessTokenAndAuthentication(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    )  throws ServletException, IOException{
        jwtExtractService.extractAccessToken(request) //사용자 요청 header에서 access 토큰 추출
                .filter(jwtCreateAndUpdateService::isTokenValid) // 토큰 유효성 검사
                .ifPresent(accessToken -&gt; jwtExtractService.extractEmail(accessToken) // 유효한 토큰이 있으면 이메일 추출
                        .ifPresent(email -&gt; userRepository.findByEmail(email) // 추출된 이메일이 존재하면 이메일로 user 검색
                                .ifPresent(this::saveAuthentication))); // 인증 허가 메소드 실행
        filterChain.doFilter(request, response); //다음 필터로 넘어가도록 설정
    }

    //Security를 사용하여 사용자를 인증 및 허가
    private void saveAuthentication(User user) {
        AuthUser authUser = AuthUser.createAuthUser(user);

        //UserDetails 객체를 사용하여 사용자의 인증 정보를 나타내는 토큰 생성
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                authUser, null, authoritiesMapper.mapAuthorities(authUser.getAuthorities()));
        SecurityContextHolder.getContext().setAuthentication(authentication); //SecurityContextHolder에 생성된 인증 객체를 설정하여 사용자의 인증 정보를 저장
    }

}
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">doFilterInternal()</code> : JWT 인증 로직을 수행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">checkRefreshTokenAndReIssueAccessToken()</code> : Refresh 토큰이 쿠키에 존재할 때 실행된다. Refresh 토큰으로 DB에서 사용자를 찾고, 사용자가 존재한다면 <code class="language-plaintext highlighter-rouge">reIssueRefreshToken()</code>메서드를 통해 토큰을 재발급 후 DB 업데이트하고, Access 토큰을 생성하여 Refresh 토큰과 함께 클라이언트로 보낸다. 만약, 사용자가 없다면 오류가 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">reIssueRefreshToken()</code> : Refresh 토큰 재발급 후 Refresh 토큰을 DB에 업데이트한다.</li>
  <li><code class="language-plaintext highlighter-rouge">checkAccessTokenAndAuthentication</code> : Refresh 토큰이 쿠키에 존재하지 않을 때 실행된다. Access 토큰이 유효한지 검사하고 유효하다면 인증 처리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">saveAuthentication()</code> : 사용자 인증 및 허가를 위한 메서드이다. Security를 통해 사용자의 인증 정보를 나타내는 토큰을 생성하여 해당 정보를 저장한다.</li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="OAuth2" /><category term="Spring" /><category term="Spring Security" /><category term="JWT" /><summary type="html"><![CDATA[JWT JWT란? JSON Web Token의 약자로 인증에 필요한 정보들을 암호화한 JSON 토큰을 의미한다. 토큰에는 사용자 관련 여러 정보가 포함되어있다. JWT를 통해 Stateless 하게 설계가 가능하다.]]></summary></entry><entry><title type="html">(도커) 도커 컴포즈</title><link href="/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88.html" rel="alternate" type="text/html" title="(도커) 도커 컴포즈" /><published>2024-02-27T00:00:00+00:00</published><updated>2024-02-27T00:00:00+00:00</updated><id>/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88</id><content type="html" xml:base="/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88.html"><![CDATA[<h2 id="도커-컴포즈-기본">도커 컴포즈 기본</h2>
<ul>
  <li>도커 컴포즈는 여러 개의 Docker 컨테이너들을 관리하는 도구이다.</li>
  <li>도커 컴포즈는 도커 데스크탑 설치 시 기본으로 설치된다.</li>
  <li>한 번의 명령어로 여러 개의 컨테이너를 한번에 실행하거나 종료할 수 있다.</li>
  <li>로컬 개발환경에서 활용하기 편리하다.</li>
  <li>도커 컴포즈를 통해 관리할 컨테이너를 docker-compose.yml파일에 정의한다.</li>
</ul>

<h3 id="도커-컴포즈-명령어">도커 컴포즈 명령어</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">docker compose up -d</code> : YAML 파일에 정의된 서비스 생성 및 시작</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose ps</code> : 현재 실행중인 서비스 상태 표시</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose build</code> : 현재 실행중인 서비스의 이미지만 빌드</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose logs</code> : 실행 중인 서비스의 로그 표시</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose down</code> : YAML 파일에 정의된 서비스 종료 및 제거</li>
  <li><code class="language-plaintext highlighter-rouge">docker compose up -d --build</code> : 로컬에 이미지가 있어도 다시 이미지를 빌드</li>
</ul>

<h3 id="도커-컴포즈-실습hitchecker">도커 컴포즈 실습(hitchecker)</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/a09d2ba0-5ceb-4c02-8936-6fe8cfe1a693" alt="image" /></p>

<ul>
  <li>hitchecker는 접속 시도 횟수를 외부 캐시 저장소인 Redis에 저장한다.</li>
  <li>hitchecker가 종료 또는 재생성되어도 Redis에 접속 시도 회수가 저장되어 있다.</li>
  <li>도커 컴포즈를 사용해서 한번에 hitchecker, Redis 서버를 구성할 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/b275bf37-6eaf-46f2-b96f-15805e8bd445" alt="image" />
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/53a1cb4a-b4c2-4b5c-9275-033abdd731c6" alt="image" /></p>

<ul>
  <li>hitchecker 프로그램을 작성한다.</li>
  <li>hitchecker 프로그램에 레디스 접속 정보를 설정하여 연결한다.</li>
  <li>’/’경로 접근 시 Redis 캐시 값을 증가 시키고 증가된 값을 출력하도록 코드를 입력한다.</li>
  <li>Dockerfile에는 애플리케이션 실행에 필요한 라이브러리를 설치하도록 작성한다.</li>
  <li>yml파일에 services 아래에 hitchecker와 redis가 함께 관리되도록 설정한다.</li>
  <li>hitchecker 컨테이너는 사용자가 개발할 애플리케이션이기 때문에 실행시 빌드가 필요하기 때문에 빌드 경로를 설정한다.</li>
  <li>hitchecker에는 외부에서 포트포워딩 할 수 있도록 ports를 통해 포트를 설정한다.</li>
</ul>

<h3 id="도커-컴포스-활용">도커 컴포스 활용</h3>
<ul>
  <li>도커 컴포즈를 통해 프론트엔드, 백엔드, 데이터베이스 컨테이너를 개발자 PC에 빠르게 구성할 수 있다.</li>
  <li>외부 모듈 개발자는 도커 컴포즈를 통해서 프로젝트의 소스코드가 없어도 환경을 빠르게 구동시킬 수 있다.</li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="Docker" /><category term="Docker" /><summary type="html"><![CDATA[도커 컴포즈 기본 도커 컴포즈는 여러 개의 Docker 컨테이너들을 관리하는 도구이다. 도커 컴포즈는 도커 데스크탑 설치 시 기본으로 설치된다. 한 번의 명령어로 여러 개의 컨테이너를 한번에 실행하거나 종료할 수 있다. 로컬 개발환경에서 활용하기 편리하다. 도커 컴포즈를 통해 관리할 컨테이너를 docker-compose.yml파일에 정의한다.]]></summary></entry><entry><title type="html">(도커) 도커와 DevOps</title><link href="/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4%EC%99%80-DevOps.html" rel="alternate" type="text/html" title="(도커) 도커와 DevOps" /><published>2024-02-27T00:00:00+00:00</published><updated>2024-02-27T00:00:00+00:00</updated><id>/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4%EC%99%80-DevOps</id><content type="html" xml:base="/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4%EC%99%80-DevOps.html"><![CDATA[<h2 id="devops--pipeline">DevOps &amp; Pipeline</h2>
<h3 id="devops">DevOps</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/83f4ead0-130e-4273-b02d-6f3550f873ae" alt="image" /></p>

<ul>
  <li>DevOps = Development(개발) + Operations(운영)</li>
  <li>개발과 운영의 거리를 줄인다.</li>
  <li>데브옵스는 애플리케이션과 서비스를 빠른 속도로 제공하기 위한 문화, 철학, 방식, 도구를 모두 포함한다.</li>
  <li>데브옵스는 컨테이너, CI/CD, 자동화, MSA, IaC 등의 개념과 연관이 있다.</li>
  <li>컨테이너는 개발자 간의 개발 환경과 배포환경과의 차이를 줄여 빠르고 안정적인 배포가 가능해진다.</li>
</ul>

<h3 id="cicd-파이프라인">CI/CD 파이프라인</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/4a046c1f-9468-48d5-bff6-e40f7fb3e296" alt="image" /></p>

<ul>
  <li>파이프라인은 소스코드부터 배포 환경 관리까지의 모든 프로세스를 자동화하는 것을 의미한다.</li>
  <li>CD (Continuous Integration)
    <ul>
      <li>지속적 통합</li>
      <li>배포가능한 아티팩트(Jar/Image)를 빌드하는 단계</li>
      <li>소스코드를 배포 가능한 아티팩트로 만드는 것을 자동화한다.</li>
    </ul>
  </li>
  <li>CD (Continuous Delivery/Deployment)
    <ul>
      <li>지속적 배포</li>
      <li>실제 환경에 아티팩트를 배포하는 단계</li>
      <li>아티팩트를 배포 환경에 배포</li>
    </ul>
  </li>
  <li>이렇게 CD/CD 파이프라인을 구성해서 빌드 및 배포 단계를 자동화하여 운영작업을 편리하게 할 수 있다.</li>
</ul>

<h3 id="github-actions">Github Actions</h3>
<ul>
  <li>Github에 소스코드를 push하면 Github Actions에서 CI/CD 파이프라인을 자동으로 실행시킬 수 있다.</li>
  <li>Github Actions을 사용하여 개발자의 PC나 별도의 빌드용 서버가 없이 파이프라인을 실행할 수 있다.</li>
  <li>프로젝트 폴더 안의 .github/workflows 폴더 안에 yml파일을 구성하여 파이프라인을 실행한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/26492c61-0302-4f9e-a0c0-937a2cd15fd8" alt="image" /></p>

<ul>
  <li>실제 진행중인 프로젝트의 workflows폴더 안의 yml 파일이다.</li>
  <li>Github가 이 파일을 자동으로 인식하여 파이프라인을 실행한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/aa8da01b-27ed-4687-8d30-91bfd3aceeb7" alt="image" /></p>

<ul>
  <li>Github에서 일정 크기의 러너 서버를 무료로 지원해준다.</li>
  <li>사용자는 러버 서버를 빌려 이 서버 위에서 Github Actions을 통해 워크플로우를 자동으로 실행할 수 있다.</li>
  <li>Github Actions에 문법에 맞게 코드를 작성하면 자동으로 코드를 읽어들여 워크 플로우가 실행된다.</li>
</ul>

<h3 id="github-actions-문법">Github Actions 문법</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/fcf2d74e-6fd5-4cc0-89d5-321eb3477fb1" alt="image" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name:</code>에 워크 플로우의 이름을 지정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">on:</code>아래에 트리거를 설정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">jobs:</code>아래에 여러 작업으로 나누어진 워크플로우를 작성한다. build-and-push로 설정하여 job을 여러개 지정할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">runs-on:</code>에 작업이 실제로 실행될 러너(서버)를 지정한다.</li>
  <li><code class="language-plaintext highlighter-rouge">steps:</code>는 각 작업을 나타내고, 여러개 지정할 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/ef6e2e88-faa0-4247-892d-57953e097c8e" alt="image" /></p>

<ul>
  <li>시간 트리거 : 특정 시간을 설정하면 해당 시간에 워크플로우가 자동으로 실행된다.</li>
  <li>푸시 트리거 : 소스코드를 변경하고 Github에 push하면 자동으로 워크 플로우를 실행한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/1ca1e918-fce4-404e-979a-8b839d66d3a9" alt="image" /></p>

<ul>
  <li>모든 작업(steps)는 러너에서 실행된다.</li>
  <li><code class="language-plaintext highlighter-rouge">steps:</code>아래의 <code class="language-plaintext highlighter-rouge">uses:</code>에 actions/checkout@v2을 사용하면 Github의 소스코드를 러너에 다운받을 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/6f4c01ed-7478-4567-b48f-7cd33d922485" alt="image" /></p>

<ul>
  <li>도커의 buildx 기능을 활성화하면 멀티플랫폼 빌드나 캐싱과 같은 기능을 사용할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">steps:</code>아래의 <code class="language-plaintext highlighter-rouge">uses:</code>에 docker/setup-buildx-action@v1을 사용하면 buildx 기능을 사용하여 도커의 기능을 확장한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/e803b180-e2e3-4130-8815-c587282b9f32" alt="image" /></p>

<ul>
  <li>도커에 로그인해야지만 이미지를 푸시할 수 있다. 따라서, 도커 로그인 정보를 입력해주어야한다.</li>
  <li><code class="language-plaintext highlighter-rouge">steps:</code>아래의 <code class="language-plaintext highlighter-rouge">uses:</code>에 docker/login-action@v1을 사용하면 도커 로그인 명령을 실행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">with:</code>아래에 도커의 로그인 정보를 입력한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/7318dd22-7232-4075-9212-2f97359c27d5" alt="image" /></p>

<ul>
  <li>Github의 시크릿 기능을 활용하여 시크릿에 입력되어 있는 로그인 정보를 가져와 사용한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/7c88c574-2130-4b17-819c-d896ede0637a" alt="image" /></p>

<ul>
  <li>build-push-action은 소스코드를 사용해서 이미지를 빌드하고 이미지를 레지스트리에 푸시하는 액션이다.</li>
  <li><code class="language-plaintext highlighter-rouge">with:</code>아래에 build-push-action에 필요한 정보를 입력한다.</li>
</ul>

<h3 id="github-actions-실제-활용">Github Actions 실제 활용</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: CICD

on:
  pull_request:
    branches: [ "develop" ]
    types: [ closed ]

jobs:
  build-and-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Make application.yml
        working-directory: ./backend
        run: |
          cd ./src/main
          mkdir resources
          cd ./resources
          touch ./application.yml
          echo "$" &gt; ./application.yml
        shell: bash

      - name: Grant execution permission for gradle
        working-directory: ./backend
        run: chmod +x gradlew

      - name: Build with Gradle Without test
        working-directory: ./backend
        run: ./gradlew clean build -x test

      - name: Docker build &amp; push
        working-directory: ./backend
        run: |
          docker login -u $ -p $
          docker build -t $/moyeobwa -f Dockerfile .
          docker push $/moyeobwa

      - name: Deploy
        uses: appleboy/ssh-action@master
        with:
          host: $
          username: ubuntu
          key: $
          port: $
          script: |
            docker stop moyeobwa
            docker rm moyeobwa
            docker image rm -f moyeobwa
            docker pull $/moyeobwa
            docker run -d -p 8080:8080 --name moyeobwa $/moyeobwa
</code></pre></div></div>
<ul>
  <li>위 yml파일은 실제 프로젝트에 사용한 워크플로우 이다.</li>
  <li>pull request가 develop 브랜치에서 닫힐 때 워크플로우가 실행된다.</li>
  <li>워크플로우 단계 구성
    <ol>
      <li>Set up JDK 17: Java 개발환경을 설정한다. JDK 17을 사용하고 Temurin 배포를 설치한다.</li>
      <li>Make application.yml: 어플리케이션의 설정 파일인 application.yml을 생성하고 시크릿으로부터 값을 이 파일에 저장한다. ./backend 폴더에서 run아래 명령어가 실행된다.</li>
      <li>Grant execution permission for gradle: Gradle 실행 권한을 부여한다.</li>
      <li>Build with Gradle Without test: Gradle을 사용하여 테스트를 제외하고 빌드한다.</li>
      <li>Docker build &amp; push: Docker 이미지를 빌드하고 Docker 레지스트리에 푸시한다. run 아래에 시크릿에서 받아온 도커 로그인 정보를 입력하고, 해당 레지스트리에 도커파일을 사용하여 이미지를 빌드하고 푸시한다.</li>
      <li>Deploy: SSH를 사용하여 호스트 서버로 접속하여 이전 버전의 컨테이너를 정지하고 삭제한 후, 새로운 Docker 이미지를 풀(pull)하여 컨테이너를 다시 실행한다. with아래에 EC2 서버 주소, 포트 등의 정보를 시크릿에서 받아와 접속하고, script에 입력된 명령어를 통해 EC2서버에 실행되어 있는 이전 컨테이너를 정지 및 삭제하고, 새롭게 생성한 이미지를 풀하여 다시 실행한다.</li>
    </ol>
  </li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="Docker" /><category term="Docker" /><summary type="html"><![CDATA[DevOps &amp; Pipeline DevOps]]></summary></entry><entry><title type="html">(도커) 도커 실무</title><link href="/jekyll-theme-yat/docker/2024/02/26/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%8B%A4%EB%AC%B4.html" rel="alternate" type="text/html" title="(도커) 도커 실무" /><published>2024-02-26T00:00:00+00:00</published><updated>2024-02-26T00:00:00+00:00</updated><id>/jekyll-theme-yat/docker/2024/02/26/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%8B%A4%EB%AC%B4</id><content type="html" xml:base="/jekyll-theme-yat/docker/2024/02/26/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EC%8B%A4%EB%AC%B4.html"><![CDATA[<h2 id="레이어-관리">레이어 관리</h2>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/aa772041-890e-438e-bb88-23ec998bdcc6" alt="image" /></p>

<ul>
  <li>Dockerfile에 작성된 지시어 1개당 레이어가 1개가 추가된다.</li>
  <li>불필요한 레이어가 많아지면 이미지의 크기ㅣ가 늘어나 빌드 속도가 느려진다.</li>
  <li>
    <p>따라서, 명령어의 수를 줄여 레이어의 개수를 최소한으로 만들어야한다.</p>
  </li>
  <li>
    <p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/20bf8a6b-73d4-4ccf-9382-832f5470f0a6" alt="image" /></p>
  </li>
  <li>이와 같이 RUN 지시어는 &amp;&amp;를 활용하여 하나의 명령어 안에서 모든 명령문이 처리되도록 한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/9bac03ba-477d-4179-815e-7b2fb26f9bd5" alt="image" /></p>

<ul>
  <li>애플리케이션의 크기를 가능한 작게 관리하여 이미지의 크기를 작게 만들어야한다.</li>
  <li>alpine OS를 사용하여 베이스 이미지를 작은 이미지로 사용할 수 있다.</li>
</ul>

<p><br /><br /></p>

<h2 id="캐싱을-활용한-빌드">캐싱을 활용한 빌드</h2>
<ul>
  <li>Dockerfile에 작성된 순서대로 결과 이미지의 레이어가 쌓인다.</li>
  <li>Docker는 각 단계의 결과 레이어를 캐시 처리한다. 지시어가 변경되지 않는다면 다음 빌드에서 레이어를 재사용한다.</li>
  <li>COPY, ADD 명령의 경우 빌드 컨텍스트의 파일 내용이 변경되어도 캐시를 사용하지 않는다.</li>
  <li>레이어가 변경되면 그 레이어와 이후의 모든 레이어는 캐시를 사용하지 않고 새로운 레이어가 만들어진다.</li>
  <li>따라서, 잘 변경되지 않는 파일들을 아래 레이어에 배치하면, 더 많은 레이어에 캐시를 적용할 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/c53f899d-51e4-47bb-9fc7-e795400b9cc2" alt="image" /></p>

<ul>
  <li>package.json, package-lock.json파일은 외부 라이브러리 정보가 저장되어 있어 개발 시 자주 변경되지 않는다.</li>
  <li>따라서, 거의 변경되지 않는 레이어와 함께 두어 캐시를 활용할 수 있도록 할 수 있다.</li>
</ul>

<p><br /><br /></p>

<h2 id="tier-아키텍처-구성">Tier 아키텍처 구성</h2>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/ff083fd6-613c-4579-9693-4268401c8749" alt="image" /></p>

<ul>
  <li>Nginx의 프록시 기술을 활용해 보안에 뛰어난 3Tier 아키텍처를 구성한다.</li>
  <li>Nginx는 특정 경로로 온 요청(/api로 시작하는 경로)를 지정한 서버로 전달된다.</li>
  <li>Nginx를 프록시 서버를 활용하여 보안 향상, 부하 관리 및 API 응답 캐싱을 활용할 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/676d55ba-e4f0-46ec-99e6-ae229956edaf" alt="image" /></p>

<ol>
  <li>클라이언트는 원하는 정보를 조회 및 저장하기 위해 웹서버에 접속한다.</li>
  <li>웹서버는 요청 프록시를 WAS에 전달한다.</li>
  <li>WAS는 DB서버에서 데이터 저징 및 조회를 진행하고 결과 값을 반환받는다.</li>
  <li>WAS는 결과 값을 활용하여 데이터를 가공하여 웹서버에 결과 값을 응답해준다.</li>
  <li>웹서버는 응답받은 데이터를 활용하여 동적화면을 구성하여 클라이언트에 결과를 전달한다.
만약, 클라리언트가 정적인 자료를 요청할 경우 웹서버는 결과 값을 바로 응답한다.</li>
</ol>

<h3 id="도커에서-tier-아키텍처-구성하기">도커에서 Tier 아키텍처 구성하기</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/cb6bf328-59e5-43c0-bd6c-8abd146c9cfa" alt="image" /></p>

<ul>
  <li>/api로 시작하는 요청은 프론트엔드 컨테이너로 프록시 되도록 설정한다. 따라서, 백엔드 컨테이너에 Host OS의 80포트의 /api경로로 접근을 시도하면 프론트엔드 컨테이너를 거쳐 접근이 가능하다.</li>
  <li>Nginx서버에서 프록시 되어 있기 때문에 외부서버에선 프론트엔드 서버에만 접근이 가능하다.</li>
  <li>데이터베이스 컨테이너는 포트포워딩 자체가 안되어있기 때문에 외부에서 접근이 불가능하다.</li>
  <li>데이터베이스 컨테이너는 백엔드 컨테이너와 레코드를 통해 연결이 되어있기 때문에 백엔드 컨테이너를 통해서 접근이 가능하다.</li>
</ul>

<p><br /><br /></p>

<h2 id="동적-서버-설정">동적 서버 설정</h2>
<ul>
  <li>Nginx서버에서 WAS 주소를 고정해서 설정해야한다.</li>
  <li>그런데 환경 별로 Nginx가 프록시 해야하는 주소는 변할 수 있다.</li>
  <li>그래서 프록시 설정의 주소를 바꾸기 위해선 이미지 빌드를 다시 해야한다.</li>
  <li>이렇게 환경 별로 달라지는 프록시 해야하는 주소같은 정보는 시스템 환경 변수로 처리하면 컨테이너 실행시 결적할 수 있다.</li>
  <li>이러한 설정을 동적 서버 설정이라 한다.</li>
</ul>

<h3 id="동적-서버-설정-방법">동적 서버 설정 방법</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/855b9188-456b-4b26-977e-90adddd4f654" alt="image" /></p>

<ul>
  <li>프론트엔드의 설정 파일을 수정하여 프록시 설정 주소를 변수로 지정하여 동적으로 값이 지정되도록 설정한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/f462d605-f8fd-445e-8475-5f0d1448294c" alt="image" /></p>

<ul>
  <li>Dockerfile을 수정하여 소스코드의 nginx.conf파일을 template 파일로 복사하고, 동적으로 지정될 기본 환경 변수를 지정한다.</li>
</ul>

<p><br /><br /></p>

<h2 id="postgresql-이중화-db-구성">PostgreSQL 이중화 DB 구성</h2>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/223e90c7-403b-47f7-9863-ccae1df3031f" alt="image" /></p>

<ul>
  <li>만약, 단일 서버로 구성하면 하나의 서버에 장애 발생 시 전체 서비스의 장애로 이어지게된다.</li>
  <li>하나의 서버에 장애가 발생하더라도 동일한 다른 서버가 동일한 역할을 수행할 수 있도록 고가용성을 보장하기 위해서 서버를 이중화하여 구성한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/2b999893-79df-41a9-9509-260f4ba0a3e2" alt="image" /></p>

<ul>
  <li>서버 이중화 DB를 구성하는 방법은 2가지이다.</li>
  <li>첫번째는 여러 DB서버가 하나의 볼륨을 사용하는 방법이다. 이 구성은 간단하지만 볼륨의 문제가 발생할 경우 대처가 어렵다.</li>
  <li>두번째는 여러 DB서버가 각각 하나씩의 볼륨을 사용하는 방법이다. 이 구성은 성능에 부하가 발생할 수 있고, 데이터의 싱크를 항상 맞추기 위해서 별도의 처리가 필요하다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/114ae254-2639-4797-a476-d16212b2f122" alt="image" /></p>

<ul>
  <li>프라이머리-스탠바이 복제 구조
    <ul>
      <li>하나의 프라이머리 서버에서만 쓰기 작업이 수행되고, 스탠바이 서버는 읽기 전용으로 사용된다.</li>
      <li>프라이머리 서버의 상태가 변경되었을 경우 스탠바이 서버에 상태를 복제한다.</li>
      <li>읽기 전용 스탠바이 서버는 여러개의 서버로 사용가능하다.</li>
    </ul>
  </li>
  <li>프라이머리-프라이머리 복제 구조
    <ul>
      <li>모든 서버에 읽기/쓰기 작업이 수행된다.</li>
      <li>여러 서버에서 동시에 쓰기 작업이 일어나 동기화 구성 작업이 매우 복잡하다.</li>
    </ul>
  </li>
</ul>

<h3 id="프라이머리-스탠바이-이중화-db-구성">프라이머리-스탠바이 이중화 DB 구성</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/b3516798-5491-43db-b460-aa5078d8d023" alt="image" /></p>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/29c37425-3177-425e-83b4-e7efc4c93f24" alt="image" />
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/4b6fa318-e974-4f95-b79d-7943fdfbe40a" alt="image" /></p>

<ul>
  <li>프라이머리와 스탠바이 노드를 같은 방식으로 실행한다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/36e66ad5-555f-49ab-8765-d30dc5beec28" alt="image" /></p>

<ul>
  <li>프라이머리 노트에는 테이블 생성 및 데이터 삽입과 같이 쓰기 작업을 수행하도록 한다.</li>
  <li>스탠바이 노드에 프라이머리의 데이터가 동기화되어 있는지 확인한다.</li>
</ul>

<p><br /><br /></p>

<h2 id="컨테이너-내부에서-개발">컨테이너 내부에서 개발</h2>
<h3 id="일반-서버에서-개발할-때-문제점">일반 서버에서 개발할 때 문제점</h3>
<ul>
  <li>개발자의 PC마다 설치된 언어 및 라이브러리 버전을 완전히 일치시키기 어려움</li>
  <li>개발 환경과 배포 환경이 다를 경우 배포 시 장애 발생</li>
  <li>새로운 개발자 합류 시 개발 환경 설버에 시간이 많이 필요하고, 개발 환경이 변화에도 많은 시간이 필요함</li>
  <li>한명이 여러 프로젝트를 담당할 경우 각 프로젝트의 환경이 모두 달라야 하는 경우 프로젝트들이 한 번에 하나의 PC에서 관리되기 힘듦</li>
</ul>

<h3 id="도커-컨테이너-내부에서-개발">도커 컨테이너 내부에서 개발</h3>
<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/f557d690-2a32-49a7-9003-850e646338b4" alt="image" /></p>

<ul>
  <li>도커를 활용하면 같은 이미지를 활용하여 개발자의 PC들과 배포 서버의 환경을 완전히 일치시킬 수 있다.</li>
  <li>IDE의 원격 개발 환경 기능을 통해 각 컨테이너별로 격리된 개발 환경을 구성할 수 있다.</li>
  <li>개발자의 PC에 프로젝트에 필요한 언어와 라이브러리의 설치가 필요가 없어 유지가 쉽다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/625a74b3-630d-431e-a559-6b73607e7ff0" alt="image" /></p>

<ul>
  <li>json파일을 통해서 일관된 개발환경을 구성할 수 있다.</li>
  <li>forwardPosts로 오픈할 포트를 입력한다. 명령어 -p와 같은 역할을 한다.</li>
  <li>postCreateCommand로 개발환경에 필요한 라이브러리를 설치하는 명령어를 입력하여 실행하도록 한다.</li>
  <li>다른 개발자와 같은 json 파일을 사용하여 개발환경을 일관되게 유지할 수 있다.</li>
</ul>

<p><img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/f67d9674-5fd2-427a-857a-2b06217ba37d" alt="image" /></p>

<ul>
  <li>실제로 개발을 수행할 컨테이너를 정의하는 도커파일을 생성한다.</li>
  <li>FROM 지시어로 베이지 이미지로 노트 14버전을 사용한다.</li>
  <li>RUN 지시어로 운영체제의 패키지를 업데이트하고 필요한 유틸들을 설치한다.</li>
  <li>ARG 지시어를 사용하여 node라는 사용자에게 적절한 권한을 부여한다.</li>
  <li>ENV 지시어를 사용하여 개발용컨테이너라는 것을 명시한다.</li>
</ul>]]></content><author><name>Yun Daehyun</name></author><category term="Docker" /><category term="Docker" /><summary type="html"><![CDATA[레이어 관리]]></summary></entry></feed>