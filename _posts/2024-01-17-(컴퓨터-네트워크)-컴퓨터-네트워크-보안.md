---
layout: post
title: (컴퓨터 네트워크) 컴퓨터 네트워크 보안
subtitle: 컴퓨터 네트워크 8장
categories: CS
tags: [CS, Network]
---

## 네트워크 보안
- 네트워크 보안 - 기밀성, 메시지 무결성, 종단점 인증, 운영 보안을 고려한 네트워크에서의 안전한 통신
  - 기밀성 - 송신자와 지정된 수신자만이 전송되는 메시지 내용을 이해할 수 있어야한다.
  - 메시지 무결성 - 통신하는 내용이 전송 도중에 변경되지 않아야한다.
  - 종단점 인증 - 통신에 참여하는 송신자와 수신자는 서로 누구인지 인증 가능해야한다.
  - 운영 보안 - 침입 감지 시스템으로 패킷은 상세히 관찰되고 의심스러운 행위에 대해 네트워크 관리에게 보고된다.
<br>

## 암호의 원리
- 암호화 알고리즘 - 평문은 암호화 알고리즘을 사용해서 암호화되어 원문이 되고, 원문은 복화화 알고리즘을 사용해서 복호화되어 평문이 된다.
<br>

## 대칭키 암호화
![image-20231105-035351](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/b750f0b8-1e2c-42d2-a929-c963f8ac9086)

- 대칭키 암호화 알고리즘 - 어떤 것을 다른 것으로 대치하는 것이다. 송신자와 수신자는 같은 키를 공유한다.
- 카이사르 암호 - 평문 + k (k=key)
- 단일 문자 대응 암호 - 각 철자들은 고유한 대응 글자로 변환된다.
- 공격의 종류
  - 암호문만을 이용한 공격 - 침입자가 평문 메시지의 내용에 대한 어떠한 사전 정보도 없이 가로챈 암호문에서만 접근할 수 있는 경우이다.
  - 알려진 평문 공격 - 침입자가 어느정도 암호문의 쌍을 알고 있을 때, 이를 사용하여 공격하는 경우이다.
  - 선택 평문 공격 - 침입자는 특정 평문 메시지를 선택하여 이에 대응하는 암호문 형태를 얻을 수 있다.
- 다중 문자 대응 암호화 - 여러 개의 단일 문자 대응법을 가지고 평문 메시지에서의 위치에 따라 서로 다른 단일 문자 대응 암호법을 사용하는 것이다.
- 블록 암호화
  - 메시지가 k비트 블록 단위로 암호화된다. 각 k비트 블록은 독립적으로 암호화된다.
  - 이 암호기법에 대한가장 단순한 공격방법은 무작정 모든 사상을 시도해보는 것이다.
  - ![image-20231105-035836](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/124d0cd9-0211-4276-b319-d7f6ba8cdcf4)
  - 블록 암호화 기법은 블록의 순열 테이블을 임의로 모방 생성하는 함수를 사용한다. 암호화 사이클을 n번 반복하게 된다.
  - 블록 암호화 방법에는 DES, AES 등이 있다.
<br>

## 공개키 암호화
![image-20231105-035902](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/afbd6a01-6aa8-4639-86bc-a2181681b528)

- 공개키 암호화 알고리즘 - 송신자와 수신자는 2개의 키를 갖는다. 하나는 세상의 모든사람에게 알려진 공개키이고, 다른 하나는 수신자만 아는 개인키이다. 송신자는 수신자의 공개키를 가지고 평문을 암호화하고, 수신자는 그것을 자신의 개인키와 이미 알려져 있는 복호화 알고리즘을 이용하여 복호화한다.
- RSA - 소인수분해의 어려움에 기반하고 있는 알고리즘이다. 매우 큰 소수를 소인수로 분해하는 것이 어렵기 때문에 공개키 암호화 알고리즘으로서 적합하다.
  - RSA 알고리즘
  - ![image-20231105-040303](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/c2a8b950-ffe7-4c9e-9acf-93d9a7948624)

  - 세션키 - RSA에 필요한 지수연산은 시간이 많이 필요하기 때문에 RSA는 실제로 종종 대칭키 암호화와 함께 사용된다. 이 키를 세션키라고 한다. 수신자는 세션키가 RSA로 암호화된 형태인 c를 받고, 이를 복호화하여 세션키 Ks를 얻게된다. 그 후로, 수신자는 송신자가 데이터 암호화에 사용한 세션키를 사용한다.
<br>

## 메시지 무결성
- 메시지 무결성을 정의하기 위해선 메시지가 정말 수신자로부터 온것인지, 수신자에게 전달되는 도중에 메시지가 변경되지 않았는지에 대해 확인이 필요하다. 
<br>

## 암호화 해시함수
![image-20231105-043119](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/b90a1a8a-e850-4805-9db0-c2c58b6864eb)

- 해시 함수는 입력 m을 받아서 해시라 불리는 고정된 크기의 문자열 H(m)을 계산해낸다.
- (m, H(m))이 원래 메시지와 그 메시지에 대해 송신자가 만들어낸 해시값이라고 할 때, 침입자가 원래 메시지와 동일한 해시값을 갖는 다른 메시지 y를 위조할 수 없다고 할 수 있어야한다.
<br> 

## 메시지 인증 코드
![image-20231105-050603](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/46d52743-304f-477c-9081-71f19d7fdb8a)

- 해시 함수로부터 메시지 무결성을 얻을 때, 가짜 메시지 m'을 생성하여 메시지 내에서 자신이 수신자라고 주장한 후, H(m')을 생성하여 수신자에게 (m', H(m))을 보내면, 문제없이 부적절한 행위를 검출할 수 없다.
- 메시지 무결성을 위해서는 암호화 해시 함수의 사용 외에도 비밀키를 공유할 필요가 있는데, 이때, 비트열 형태인 이 공유 비밀키를 인증키라고 한다.
- 메시지 무결성 적용 방법
  - 수신자는 메시지 m을 생성한 후 s와 접합하여 m+s를 만든다. 그런 다음 해시 H(m+s)를 계산해내는데 이것을 메시지 인증 코드(MAC)라고 부른다.
  - 송신자는 MAC을 메시지 m에 첨부하여 확장 메시지 (m, H(m+s))를 생성해서 수신자에게 보낸다.
  - 수신자는 확장 메시지 (m, h)를 받으면 이미 알고있는 s를 이용하여 MAC H(m+s)를 계산한다. 만약, H(m+s) = h라면, 아무 문제가 없는 것이다.
- MAC은 암호화 알고리즘을 필요로 하지 않는다. 즉, 메시지의 무결성만 필요로 하고 메시지 기밀성은 고려하지 않는다.
<br>

## 전자서명
- 디지털 세계에서 자신의 문서 내용에 대해 승인했거나 동의했다는 사실을 증명하는 목적으로 사용되는 암호화 기법을 말한다.
- 서명자를 입증할 수 있어야 하고, 위조할 수 없도록 해야한다. 즉, 어느 한 개인이 서명한 무서를 실제로 그 사람이 서명했다는 사실, 그리고 오직 그 사람만이 문서에 서명할 수 있었다는 사실을 증명할 수 있어야 한다.
- 전자서명 생성방법
- ![image-20231105-051655](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/a8452659-fdef-4c0f-a3c8-bcccf44001db)

- 수신자는 문서에 서명할 목적으로 개인키를 사용하여 알고리즘을 계산한다.
- 개인키를 사용하는 이유는 KB+(KB−(m))=m이 되도록하기 위해서 이다.
- 개인키를 사용하였기 때문에 개인키를 알고있는 자신 이외에 다른 사람들은 생성 불가능하다.
- 전자서명 메시지의 전송
- ![image-20231105-052018](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/9a731901-7e0a-4b78-9801-075d36386eea)

- 서명된 메시지의 검증
- ![image-20231105-052042](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/14d14d68-2012-423b-850d-913f1ac6c9cc)

- 공개키 인증 - 전자서명의 중요한 응용 중 하나로 어떤 공개키가 특정 통신 개체에 속한다는 것을 보증하는 것이다.
  - IPsec과 TLS 등 많은 대중적인 보안 네트워킹에서 사용된다.
  - ![image-20231105-052233](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/dde0b2ed-0b31-440a-81fc-b926bdf4f967)

  - 공격자는 송신자에게 자신이 수신자라고 속이고 자신의 개인키로 이용해 서명된 메시지 요약문을 송신자에게 보낸다. 송신자는 그것이 수신자의 것이라고 생각하여 공격자의 공개키를 이용하여 암호화하여 수신자에게 보낸다. 당연하게도 수신자는 자신이 원한 메시지가 아닌 잘못된 메시지를 가지게 된다.
- 인증기관(CA) - 공개키가 어떤 특정한 통신 개체의 것인지 보증하는 일을 담당한다.
  - CA는 어떤 개체가 스스로 주장하는 자신의 신분, 바로 그 개체가 맞는지 확인한다.
  - 일단 CA가 개체의 신원을 확인하면, CA는 그 개체의 공개키와 신분확인서를 결합한 인증서를 만든다
  - ![image-20231105-053434](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/c1509ee8-efa9-4654-8b1b-764b6fe0f405)
<br> 

## 종단점 인증
- 하나의 통신 개체가 다른 개체에게 자신의 신원을 컴퓨터 네트워크상으로 증명하는 작업이다.
- 종단점 인증 시나리오
  - 송신자는 메시지를 수신자에게 보낸다.
  - 수신자는 넌스 R을 선택하고 그것을 송신자에게 보낸다.
  - 송신자는 송신자와 수신자의 대칭 비밀키르르 사용해서 그 넌스를 암호화하고, 암호화된 넌스를 밥에게 보낸다.
  - 수신자는 자신이 받은 메시지를 복호화한다. 만약 복호화한 넌스가 자신이 송신자에게 보낸 것과 같다면 송신자를 인증한다.
  - ![image-20231105-053818](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/b2143690-d142-4050-9c9a-3653814c4226)
 <br>

## TCP연결의 보안 : TLS
- TCP에서 기밀성, 데이터 무결성, 종단점 인증 등의 보안 서비스를 포함하는 버전을 TLS라고 부른다.
- almost-TLS는 핸드셰이크, 키 유도, 데이터 전송이라는 세 단계에서 보안을 제공한다.
- 핸드셰이크
  - (a) 송신자는 TCP연결을 설립한다.
  - (b) 수신자는 송신자가 진짜 송신자인지 확인한다.
  - (c) TLS 세션에 필요한 모든 대칭키를 생성하기 위해 앨리스와 밥이 사용할 주 비밀키를 수신자에게 전송한다.  
  - 이렇게 TCP연결이 성립되면 수신자는 송신자에게 메시지를 보내고, 여기에 송신자는 수신자의 공개키를 담은 인증서로 응답한다.
  - 수신자는 인증서 내의 공개키가 CA로부터 인증받은 것이기 때문에 수신자의 것이라는 사실을 확실히 믿을 수 있다.
  - 수신자는 MS를 생성하여 이를 송신자의 공개키로 암호화하여 EMS를 만든다.
  - EMS가 송신자에게 전송되고 송신자는 자신의 개인키를 가지고 EMS를 복호화하여 MS를 얻는다.
  - ![image-20231105-061351](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/9783d569-e881-40a7-b1d1-465a770272ea)

- 키유도
  - 원칙적으로 송신자와 수신자가 공유한 MS는 이후의 모든 암호화와 데이터 무결성 검사를 위한 대칭 세션키로 사용될 수 있다. 하지만 일반적으로 앨리스와 밥이 각각 다른 암호화 키를 사용하고, 암호화와 무결성 검사에도 서로 다른 키를 사용하는 것이 좀 더 안전하기 때문에 MS를 이용하여 4개의 키를 생성한다.
- 데이터 전송
  - 핸드 셰이크와 키유도를 통해 TCP연결이 되었기 때문에 송, 수신자는 서로에게 안전한 데이터를 보낼 수 있다.
  - 송신자 쪽의 TCP는 모든게 잘 처리되었다고 생각하고 그 두 레코드를 TLS 부계층에 넘겨준다.
  - 송신자 쪽의 TLS가 두 레코드를 복화화한다.
  - 송신자 쪽의 TLS가 각 레코드의 HMA을 사용하여 두 레코드의 데이터 무결성을 확인한다.
  - TLS는 두 레코드의 복호화된 바이트 스트림을 애플리케이션 계층에 넘겨준다. 그러나 순서가 뒤 바뀐  두 레코드 때문에 앨리스가 받은 전체 바이트 스트림은 순서가 맞지 않는다.
<br> 

## 네트워크 계층 보안 : IPsec
![image-20231105-062012](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/0c43e7f5-b5ea-4cc4-bd07-04aa4146dbc9)

- IPsec - 호스트 사이의 IP 데이터 그램을 보호한다. 또한, 공공 인터넷 상에 가상 사설 네트워크를 구축하기 위해 IPsec이 사용된다. IP 데이터 그램에 기밀성, 출발지 인증, 데이터 무결성, 재생 공격 방지 같은 보안 서비스를 추가한다.
- AH, ESP 프로토콜 - 출발지 IPsec 개체가 보안 데이터그램을 목적지 개체에 보낼 때 AH 프로토콜이나 ESP 프로토콜을 사용한다. AH 프로토콜은 출발지 인증과 데이터 무결성을 제공하지만 기밀성은 제공하지 않는다. ESP프로토콜은 출발지 인증, 데이터 무결성, 기밀성을 제공한다.
- SA - IPsec 데이터그램을 전송하기 전에 출발지 개체와 목적지 개체는 네트워크 계층에서 논리적 연결을 설립한다. 이러한 논리적 연결을 SA라고 한다. SA는 단방향 연결이기 때문에 양방향으로 2개의 SA가 설립되어야한다.
- IPsec 데이터 그램
  - 터널 모드와 전송 모드라는 두가지 패킷 형식을 갖는다. 주로 VPN에 터널모드가 더 적합하여 터널보드가 더 널리 사용된다.

