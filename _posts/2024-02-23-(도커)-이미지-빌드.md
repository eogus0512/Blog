---
layout: post
title: (도커) 이미지 빌드
subtitle: 개발자를 위한 쉬운 도커 (데브위키)
categories: Docker
tags: [Docker]
---
`
## 이미지레이어
![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/40050cea-bd96-47a4-aa67-bdd3cc254206)

- 도커 이미지는 저장소를 효율적으로 사용하기 위해서 레이어드 파일 시스템으로 구성
- 이미지를 다운로드 받을 때 여러개의 pull이 실행되는데 이것은 여러개의 레이어를 의미한다.
- 레이어드 파일 시스템은 공간을 효율적으로 사용할 수 있다.
- 이미지를 저장하고 전송할 때 스토리지와 네트워크 사용량을 절약할 수 있다.
<br>

![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/5e6a670f-e76f-4177-a794-06d317e1d00b)

1. OS파일 시스템 준비
2. OS에서 Nginx 소프트웨어 설치, 이전 레이어인 OS 레이어에서 NGINX 소프트웨어가 추가된 부분만 따로 가지게 됨
3. Nginx 설정 파일인 nginx.conf파일 작성
4. 이미지 A와 B의 index.html 파일의 내용만 다르게 작성, 1, 2, 3번의 레이어는 같음
- 레이어는 순차적으로 쌓이고, 각각의 레이어는 이전 레이어에서 변경된 부분을 저장, 같은 변경이 일어난 레이어는 공유에서 재사용될 수 있다.
- 컨테이너가 실행중에 생기는 모든 변경 사항들은 새로운 레이어에 저장됨
- 이미지 레이어 - 컨테이너를 실행하기 위한 세이브 포인트 역할
- 컨테이너 레이어 - 실제로 이미지를 컨테이너로 실행한 다음 프로세스가 변경하는 내용을 기록
- 동일한 이미지로 컨테이너를 많이 만들어도 이미지로 실행된 모든 컨테이너가 하나의 이미지를 공유해서 읽어옴
- 읽기 전용 레이어를 통해 실행 속도를 증가시킬 수 있고, 컨테이너가 늘어나면서 사용하는 공간을 최대한 작게 관리할 수 있다.
- 정리하면, 읽기 전용 레이어이란 설계도로 여러 컨테이너를 생성할 수 있다는 것이다.

### 이미지 레이어 명령문
- `docker image history 이미지명` - 해당 이미지가 어떻게 구성되어 있는지 확인

### 이미지 레이어 정리
- Layering - 각 레이어는 이전 레이어 위에 쌓이며,여러 이미지 간에 공유될 수 있다. 레이어 방식은 중복 데이터를 최소화하고, 빌드 속도를 높이며, 저장소를 효율적으로 사용할 수 있게 해준다
- Copy-on-Write(CoW) 전략 - 다음 레이어에서 이전 레이어의 특정 파일을 수정 할 때,해당 파일의 복사본을 만들어서 변경 사항을 적용한다.이렇게 함으로써 원래 레이어는 수정되지 않고 그대로 유지된다.
- ImmutableLayers(불변 레이어) - 이미지의 각 레이어는 불변으로, 한 번 생성되면 변경되지 않는다. 이렇게 함으로써 이미지의 일관성을 유지하고,여러 컨테이너에서 안전하게 공유할 수 있다.
- Caching(캐싱) - 레이어를 캐시하여, 이미 빌드된 레이어를 재사용할 수 있다. 이는 이미지 빌드 시간을 크게 줄여주며,같은 레이어를 사용하는 여러 이미지에서 효율적으로 작동한다.
<br>

## 이미지 커밋
- 커밋 - 실행 중인 컨테이너를 그 상태 그대로 이미지로 만들어내는 방식

![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/d540c005-12a1-429e-a40f-f8623edb7ab1)

1. Nginx이미지를 컨테이너로 실행한다.
2. 컨테이너의 내부 파일을 변경한다.
3. 현재 컨테이너의 상태를 Commit으로 새로운 이미지 저장한다.

### 이미지 커밋 명령문
- `docker run -it --name 컨테이너명 이미지명 bin/bash` - 컨테이너 실행과 동시에 터미널 접속, cmd 대신 shell로 사용자가 접근
- `docker commit -m 커밋명 실행중인컨테이너명 생성할이미지명` - 실행 중인 컨테이너를 이미지로 생성
<br>

## 이미지 빌드
- 빌드 - 도커 파일이라는 명세서를 통해서 이미지를 만드는 방식

### IaC(Infrastructure as Code)

![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/ba857ede-ddb7-4858-9e21-c82e7e82362a)

- 인프라 상태를 코드로 관리, 프로그램은 자동으로 사람이 작성한 코드를 읽어 인프라를 관리한다.
- 코드에 들어가는 내용은 프로그램이 작업하기 위한 일련의 작업 명세서로 사용된다.
- 도커 - IaC 방식 사용
  
  - ![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/dbb5bda7-7cc0-4415-a331-702070b21e17)

  - 도커에서 빌드 방식을 사용하면 컨테이너를 생성하고 커밋하는 것을 도커가 대신 수행해준다.
  - 도커파일 - 도커에게 어떤 작업을 수행할지 코드로 작성한 것
  - 도커는 IaC방식에 따라서 이미지를 도커 파일이라는 소스 코드로 관리할 수 있다. 코드이기 때문에 애플리케이션 소스 코드와도 함꼐 관리할 수 있고 버전관리도 가능하다.
  - 도커는 도커파일을 해석하여 이미지를 제작한다.
  - 도커는 사람대신 도커 파일의 지시어를 통해 빌드를 진행해줘 오류가 발생하는것을 방지할 수 있다.
  - 커밋 방식을 사용하면 여러 레이어를 여러번의 커밋과정을 거쳐 이미지를 생성하는 반면, 빌드 방식은 도커가 직접 이러한 작업들을 반복해주기 때문에 레이어 구조를 편리하게 활용할 수 있다. 

### 이미지 빌드 명령문
- `docker build -t 이미지명 Dockerfile경로` - 도커파일을 통해 이미지 빌드
- 도커파일 문법
  - FROM 이미지명 - 베이스 이미지를 지정
  - COPY 파일경로 복사할경로 - 파일을 레이어에 복사
  - CMD ["명령어"] - 컨테이너 실행 시 명령어 지정
<br>

## DockerFile 지시어
![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/51baccd7-7247-4d1f-bae5-9d8dd2a5c8db)

- 애플리케이션 빌드 - 소스코드를 실행 가능한 프로그램으로 만드는 과정, 결과물 아티팩트
- 이미지 빌드 - 도커 파일을 이미지로 만드는 과정, 개발자가 개발한 소스코드를 애플리케이션 이미지로 필드할 때, 이미지 빌드 과정에 애플리케이션 빌드 과정이 포함되어 있다.
- `docker build -f 도커파일명 -t 이미지명 Dockerfile경로` - 도커파일명이 Dockerfile이 아닌 경우 별도 지정
- 기본 지시어
  - FROM 이미지명 - 베이스 이미지를 지정
  - COPY 빌드컨텍스트경로 레이어경로 - 빌드 컨텍스트의 파일을 레이어에 복사
  - RUN 명령어 - 명령어 실행
  - CMD ["명령어"] - 컨테이너 실행 시 명령어 지정
  - WORKDIR 폴더명 - 작업 디렉토리를 지정
  - USER 유저명 - 명령을 실행할 사용자 변경
  - EXPOSE 포트번호 - 컨테이너가 사용할 포트를 명시
  - ARG 변수명 변수값 - 이미지 빌드 시점의 환경 변수 설정 (docker build --build -arg 변수명=변수값 으로 덮어쓰기 가능)
  - ENV 변수명 변수값 - 이미지 빌드 및 컨테이너 실행 시점의 환경 변수 설정 (docker run -e 변수명=변수값 으로 덮어쓰기 가능)
  - ENTRYPOINT ["명령어"] - 고정된 명령어를 지정
<br>

## 멀티 스테이지 빌드
- 빌드에 사용하는 이미지와 실행에 사용하는 이미지를 함께 활용하는 방법

- ![image](https://github.com/eogus0512/eogus0512.github.io/assets/71585151/967f3abe-f56c-4348-9db7-ed787480d814)

- 빌드에 사용하는 이미지와 실행에 사용하는 이미지를 분리하여 생성하고, 사용
- 분리를 통해 다운로드 속도를 높일 수 있음
- 빌드 스테이지와 실행 스테이지로 나누어서 빌드하는 방식을 `멀티 스테이지 빌드`라고 한다.

```
# 첫번째 단계:	빌드 환경 설정
FROM maven:3.6	AS build
WORKDIR /app

# 소스코드 복사
COPY pom.xml .
COPY src ./src

# 애플리케이션 빌드
RUN mvn clean package

# 두번째 단계:	실행 환경 설정
FROM openjdk:11-jre-slim
WORKDIR /app

# 빌드 단계에서 생성된 JAR	파일 복사
COPY --from=build /app/target/*.jar ./app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```
- 첫번째 FROM 지시자를 사용하여 JAVA 애플리케이션을 빌드하기 위해 maven 베이스 이미지 사용
- RUN 지시자를 사용하여 JAVA 애플리케이션을 빌드
- 두번째 FROM 지시자를 사용하여 JAVA 애플리케이션을 실행하기 위해 openjdk 베이스 이미지 사용
- COPY 지시자를 사용하여 build에서 실행 이미지로 파일을 복사한다.













