<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>(컴퓨터 네트워크) 네트워크 계층 - 제어 평면 | 대현’s 개발일지</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="(컴퓨터 네트워크) 네트워크 계층 - 제어 평면">
<meta name="author" content="Yun Daehyun">
<meta property="og:locale" content="ko">
<meta name="description" content="라우팅 알고리즘 라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것이다. 그래프 : G(N, E)로 나타내고, N과 E는 각각 노드와 엣지의 집합이고, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시된다. 라우팅 알고리즘의 분류 중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 핵식점인 특징은 알고리즘이 연결과 링크 비용에 대한 완전한 정보를 갖는다는 점이다. 전체 상태 정보를 갖는 알고리즘을 링크 상태(link-state) 알고리즘이라고 한다. 분산 라우팅 알고리즘 : 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고 있지는 않다. 대신 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작한다. 이후 반복된 계산과 이웃 노드와의 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지의 최소 비용 경로를 계산한다. (예) 거리 벡터 알고리즘)">
<meta property="og:description" content="라우팅 알고리즘 라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것이다. 그래프 : G(N, E)로 나타내고, N과 E는 각각 노드와 엣지의 집합이고, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시된다. 라우팅 알고리즘의 분류 중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 핵식점인 특징은 알고리즘이 연결과 링크 비용에 대한 완전한 정보를 갖는다는 점이다. 전체 상태 정보를 갖는 알고리즘을 링크 상태(link-state) 알고리즘이라고 한다. 분산 라우팅 알고리즘 : 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고 있지는 않다. 대신 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작한다. 이후 반복된 계산과 이웃 노드와의 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지의 최소 비용 경로를 계산한다. (예) 거리 벡터 알고리즘)">
<link rel="canonical" href="/jekyll-theme-yat/cs/2024/01/11/(%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-_-%EC%A0%9C%EC%96%B4-%ED%8F%89%EB%A9%B4.html">
<meta property="og:url" content="/jekyll-theme-yat/cs/2024/01/11/(%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-_-%EC%A0%9C%EC%96%B4-%ED%8F%89%EB%A9%B4.html">
<meta property="og:site_name" content="대현’s 개발일지">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-01-11T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="(컴퓨터 네트워크) 네트워크 계층 - 제어 평면">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun Daehyun"},"dateModified":"2024-01-11T00:00:00+00:00","datePublished":"2024-01-11T00:00:00+00:00","description":"라우팅 알고리즘 라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것이다. 그래프 : G(N, E)로 나타내고, N과 E는 각각 노드와 엣지의 집합이고, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시된다. 라우팅 알고리즘의 분류 중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 핵식점인 특징은 알고리즘이 연결과 링크 비용에 대한 완전한 정보를 갖는다는 점이다. 전체 상태 정보를 갖는 알고리즘을 링크 상태(link-state) 알고리즘이라고 한다. 분산 라우팅 알고리즘 : 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고 있지는 않다. 대신 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작한다. 이후 반복된 계산과 이웃 노드와의 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지의 최소 비용 경로를 계산한다. (예) 거리 벡터 알고리즘)","headline":"(컴퓨터 네트워크) 네트워크 계층 - 제어 평면","mainEntityOfPage":{"@type":"WebPage","@id":"/jekyll-theme-yat/cs/2024/01/11/(%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-_-%EC%A0%9C%EC%96%B4-%ED%8F%89%EB%A9%B4.html"},"url":"/jekyll-theme-yat/cs/2024/01/11/(%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-_-%EC%A0%9C%EC%96%B4-%ED%8F%89%EB%A9%B4.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="images/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/jekyll-theme-yat/assets/css/main.css">
  <script src="/jekyll-theme-yat/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/jekyll-theme-yat/feed.xml" title="대현's 개발일지">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/jekyll-theme-yat/">
  <img class="site-favicon" title="대현's 개발일지" src="images/favicon.png" onerror="this.style.display='none'">
  대현's 개발일지
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/jekyll-theme-yat/about.html">ABOUT</a><a class="page-link" href="/jekyll-theme-yat/archives.html">ARCHIVES</a><a class="page-link" href="/jekyll-theme-yat/categories.html">CATEGORIES</a><a class="page-link" href="/jekyll-theme-yat/">HOME</a><a class="page-link" href="/jekyll-theme-yat/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'ko',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">(컴퓨터 네트워크) 네트워크 계층 - 제어 평면</h1>
  <h2 class="post-subtitle">컴퓨터 네트워크 5장</h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2024-01-11T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 11, 2024
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 9 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/jekyll-theme-yat/tags.html#CS">#CS</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#Network">#Network</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="라우팅-알고리즘">라우팅 알고리즘</h2>
<ul>
  <li>라우팅 알고리즘의 목표는 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것이다.</li>
  <li>그래프 : G(N, E)로 나타내고, N과 E는 각각 노드와 엣지의 집합이고, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시된다.</li>
  <li>라우팅 알고리즘의 분류
    <ul>
      <li>중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 핵식점인 특징은 알고리즘이 연결과 링크 비용에 대한 완전한 정보를 갖는다는 점이다. 전체 상태 정보를 갖는 알고리즘을 링크 상태(link-state) 알고리즘이라고 한다.</li>
      <li>분산 라우팅 알고리즘 : 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.  어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고 있지는 않다. 대신 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작한다. 이후 반복된 계산과 이웃 노드와의 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지의 최소 비용 경로를 계산한다. (예) 거리 벡터 알고리즘)
<br>
</li>
    </ul>
  </li>
</ul>

<h2 id="링크-상태ls-라우팅-알고리즘">링크 상태(LS) 라우팅 알고리즘</h2>
<ul>
  <li>다익스트라 알고리즘 : 하나의 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산한다. 네트워크 전체 정보를 이용한다.</li>
  <li>D(v) : 알고리즘이 현재 반복 시점에서 출발지 노드부터 목적지 v까지의 최소 비용 경로의 비용</li>
  <li>p(v) : 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드</li>
  <li>N’ : 노드의 집합. 출발지에서 v까지의 최소 비용 경로가 명확히 알려져 있다면, v는 N’에 포함된다.</li>
  <li>
    <p>출발지 노드 u를 위한 링크 상태(LS) 알고리즘
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/8aa9071a-9d9d-473d-a303-2c7efe802bff" alt="image-20231008-130643"></p>
  </li>
  <li>
    <p>링크 상태 알고리즘 수행 결과 예시
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/1eef9e45-1828-48d5-a82e-d8dd4a36cc0d" alt="image-20231008-131015"></p>
  </li>
  <li>최소 비용 경로와 포워딩 테이블
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/565bd4de-f359-4927-9391-20458a8c9f67" alt="image-20231008-131108">
<br>
</li>
</ul>

<h2 id="거리-벡터dv-라우팅-알고리즘">거리 벡터(DV) 라우팅 알고리즘</h2>
<ul>
  <li>특징
    <ul>
      <li>분산적 : 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포한다.</li>
      <li>반복적 : 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다.</li>
      <li>비동기적 : 톱니바퀴 돌듯이 모든 노드가 서로 정확히 맞물려 통작할 필요가 없다.</li>
    </ul>
  </li>
  <li>
    <p>DV 알고리즘에서 노드x부터 y까지 최소 비용 경로의 비용
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/7039559b-03b9-4c99-9900-225cb40fde42" alt="image-20231008-131515"></p>
  </li>
  <li>
    <p>거리 벡터(DV) 알고리즘 <br>
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/47d67891-b796-4684-961b-69a20939e537" alt="image-20231008-135845"></p>
  </li>
  <li>DV 알고리즘에서는 어떤 노드 x가 자신에게 직접 연결된 링크 중 하나의 비용이 변경된 사실을 알게 되거나 어떤 이웃으로부터 변경된 거리 벡터를 수신했을 때 자신의 거리 벳터 추정값을 갱신한다.</li>
  <li>거리벡터 알고리즘 동작
<img src="https://github.com/eogus0512/eogus0512.github.io/assets/71585151/e709affd-3cdb-4085-817f-cd3dae4c3a2a" alt="image-20231008-140035">
<br>
</li>
</ul>

<h2 id="링크-상태-알고리즘과-거리-벡터-라우팅-알고리즘의-비교">링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교</h2>
<ul>
  <li>DV 알고리즘에서 각 노드는 오직 직접 연결된 이웃과만 메시지를 교환하지만, 자신으로부터 네트워크 내 모든 노드로의 최소 비용 추정값을 이웃들에게 제공한다. 반면 LS 알고리즘은 전체 정보를 필요로 한다. 
<br>
</li>
</ul>

<h2 id="인터넷에서의-as-내부-라우팅--ospf">인터넷에서의 AS 내부 라우팅 : OSPF</h2>
<ul>
  <li>네트워크를 여러 개의 자율 시스템(Autonomous System)으로 나누고 같은 AS 안에 있는 라우터들은 동일한 라우팅 알고리즘을 사용하는데 이러한 라우팅 알고리즘을 AS 내부 라우팅 프로토콜이라고 한다.</li>
  <li>개방형 최단 경로 우선(OSPF) 프로토콜
    <ul>
      <li>링크 상태 정보를 플러딩 하고, 다익스트라 최소 비용 경로 알고리즘을 사용하는 링크 상태 알고리즘이다.</li>
      <li>OSPF를 이용하여 각 라우터는 전체  AS에 대한 완벽한 토폴로지 지도(그래프)를 얻는다.</li>
      <li>OSPF를 사용하는 라우터는 인접한 라우터만이 아니라 자율 시스템 내의 다른 모든 라우터에게 라우팅 정보를 브로드캐스팅한다.
<br>
</li>
    </ul>
  </li>
</ul>

<h2 id="인터넷-서비스-제공업자isp간의-라우팅--bgp">인터넷 서비스 제공업자(ISP)간의 라우팅 : BGP</h2>
<ul>
  <li>목적지가 AS 외부에 있는 경우 BGP를 이용하여 전달된다.</li>
  <li>BGP의 임무
    <ul>
      <li>이웃 AS를 통해 도달 가능한 서브넷 프리픽스 정보를 얻는다.</li>
      <li>서브넷 주소 프리픽스로의 가장 좋은 경로를 결정한다.</li>
    </ul>
  </li>
  <li>BGP 경로
    <ul>
      <li>eBGP : 2개의 AS를 연결하는 BGP 연결</li>
      <li>iBGP : 같은 AS 내의 라우터 간 BGP 연결</li>
      <li>도달 가능성 정보를 전파하기 위해서는 iBGP와 eBGP 연결이 모두 사용된다.</li>
      <li>특정 목적지까지 다른 많은 경로가 존재할 수 있고 각기 다른 일련의 AS들을 통과하기도 한다.</li>
    </ul>
  </li>
  <li>최고의 경로 결정
    <ul>
      <li>수많은 경로 중 라우터는 최선의 경로를 선택해야한다.</li>
      <li>AS-PATH : 프리픽스가 어떤 AS에 전달되었을 때 그 AS는 자신의 AN은 AS-PATH 내 현재 리스트에 추가한다.</li>
      <li>NECT-HOP : AS-PATH가 시작되는 라우터 인터페이스의 IP 주소이다.</li>
    </ul>
  </li>
  <li>뜨거운 감자 라우팅
    <ul>
      <li>라우터가 목적지까지의 경로 중 자신의 AS 바깥에 있는 부분에 대한 비용은 신경쓰지 않고 최대한 신속하게 패킷을 자신의 AS 밖으로 내보내는 것이다.</li>
      <li>비용은 신경쓰지 않고 자신의 AS 내부 비용만 줄이기 위해 당장의 최선의 다음 라우터를 선택한다.</li>
    </ul>
  </li>
  <li>BGP 경로 선택 알고리즘
    <ul>
      <li>속성중 하나로서 지역 선호도가 경로에 할당 된다. 지역 선호도의 값은 온전히 AS 네트워크 관리자에 의한 정책이다. 최고 지역 선호 값을 가진 경로가 선택된다.</li>
      <li>최고 지역 선호값을 가진 경로가 여러 개 있다면 이들 중에서 최단 AS-PATH를 가진 경로가 선택된다. 여기서 거릿값으로는 라우터 홉 수 보다는 AS 홉 수를 사용한다.</li>
      <li>남은 경로들에 대해 뜨거운 감자 라우팅을 수행한다. 즉, NEXT-HOP 라우터까지의 거리가 가장 가까운 경로가 선택된다.</li>
      <li>아직도 하나 이상의 경로가 남아있다면 라우터는  BGP 식별자를 사용하여 경로를 선택한다.</li>
    </ul>
  </li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/jekyll-theme-yat/spring/2024/01/09/(%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC)-%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84.html" title="(스프링 핵심원리) 빈 스코프">(스프링 핵심원리) 빈 스코프</a><a class="next" href="/jekyll-theme-yat/cs/2024/01/17/(%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B3%B4%EC%95%88.html" title="(컴퓨터 네트워크) 컴퓨터 네트워크 보안">(컴퓨터 네트워크) 컴퓨터 네트워크 보안</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/jekyll-theme-yat/docker/2024/02/27/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4%EC%99%80-DevOps.html" title="(컴퓨터 네트워크) 컴퓨터 네트워크 보안">(도커) 도커와 DevOps</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/docker/2024/02/25/(%EB%8F%84%EC%BB%A4)-%EB%8F%84%EC%BB%A4-%EB%B3%BC%EB%A5%A8.html" title="(컴퓨터 네트워크) 컴퓨터 네트워크 보안">(도커) 도커 볼륨</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/java/2024/06/04/(%EC%9E%90%EB%B0%94)-%EC%8A%A4%ED%8A%B8%EB%A6%BC-(Stream).html" title="(컴퓨터 네트워크) 컴퓨터 네트워크 보안">(자바) 스트림 (Stream)</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/spring/2023/12/23/(%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC)-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%9B%90%EB%A6%AC.html" title="(컴퓨터 네트워크) 컴퓨터 네트워크 보안">(스프링 핵심원리) 객체 지향 원리</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-theme-yat/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2024 Yun Daehyun</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/jekyll-theme-yat/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
